<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>shamanAI - Продвинутый ИИ Агент</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.10.0/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/universal-sentence-encoder@1.3.3/dist/universal-sentence-encoder.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/tesseract.js@4.1.1/dist/tesseract.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.3.0/dist/chart.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/axios@1.4.0/dist/axios.min.js"></script>
    <style>
        :root {
            --primary: #8A2BE2;
            --secondary: #00CED1;
            --accent: #FF1493;
            --dark: #1A1A2E;
            --light: #F0F8FF;
            --neon-glow: 0 0 10px var(--secondary), 0 0 20px var(--secondary), 0 0 30px var(--accent);
            --matrix: #00FF41;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Courier New', monospace;
        }

        body {
            background: linear-gradient(135deg, var(--dark) 0%, #16213E 50%, #0F3460 100%);
            color: var(--light);
            min-height: 100vh;
            overflow-x: hidden;
            position: relative;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                repeating-linear-gradient(
                    0deg,
                    transparent,
                    transparent 2px,
                    rgba(0, 255, 65, 0.1) 2px,
                    rgba(0, 255, 65, 0.1) 4px
                );
            pointer-events: none;
            z-index: -1;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            padding: 30px 0;
            border-bottom: 3px solid var(--primary);
            margin-bottom: 30px;
            animation: glow 2s ease-in-out infinite alternate;
            position: relative;
            overflow: hidden;
        }

        @keyframes glow {
            from { 
                text-shadow: var(--neon-glow);
                box-shadow: 0 0 20px var(--primary);
            }
            to { 
                text-shadow: 0 0 15px var(--accent), 0 0 25px var(--accent), 0 0 35px var(--primary);
                box-shadow: 0 0 30px var(--accent);
            }
        }

        .shaman-title {
            font-size: 4rem;
            background: linear-gradient(45deg, var(--primary), var(--secondary), var(--accent), var(--matrix));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 10px;
            position: relative;
        }

        .shaman-title::after {
            content: '██';
            animation: blink 1s infinite;
            margin-left: 10px;
            color: var(--matrix);
        }

        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }

        .tagline {
            font-size: 1.2rem;
            opacity: 0.8;
            color: var(--matrix);
        }

        .main-grid {
            display: grid;
            grid-template-columns: 1fr 400px;
            gap: 30px;
            margin-bottom: 30px;
        }

        .chat-container {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 20px;
            border: 2px solid var(--primary);
            backdrop-filter: blur(10px);
            box-shadow: var(--neon-glow);
            overflow: hidden;
            position: relative;
        }

        .chat-messages {
            height: 500px;
            overflow-y: auto;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            background: rgba(0, 0, 0, 0.3);
        }

        .message {
            max-width: 80%;
            padding: 15px;
            border-radius: 15px;
            position: relative;
            animation: messageSlide 0.3s ease-out;
            line-height: 1.5;
        }

        @keyframes messageSlide {
            from { transform: translateY(20px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        .user-message {
            align-self: flex-end;
            background: linear-gradient(135deg, var(--primary), #9370DB);
            border-bottom-right-radius: 5px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .ai-message {
            align-self: flex-start;
            background: linear-gradient(135deg, var(--secondary), #20B2AA);
            border-bottom-left-radius: 5px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .input-area {
            display: flex;
            padding: 20px;
            gap: 10px;
            border-top: 2px solid var(--primary);
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(5px);
        }

        .chat-input {
            flex: 1;
            padding: 15px;
            border: 2px solid var(--secondary);
            border-radius: 10px;
            background: rgba(255, 255, 255, 0.1);
            color: var(--light);
            font-size: 16px;
            outline: none;
            transition: all 0.3s ease;
            font-family: 'Courier New', monospace;
        }

        .chat-input:focus {
            box-shadow: 0 0 15px var(--secondary);
            border-color: var(--matrix);
        }

        .tools-panel {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 20px;
            border: 2px solid var(--secondary);
            padding: 20px;
            backdrop-filter: blur(10px);
            box-shadow: 0 0 20px rgba(0, 206, 209, 0.3);
        }

        .tool-section {
            margin-bottom: 25px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .tool-title {
            font-size: 1.3rem;
            margin-bottom: 15px;
            color: var(--secondary);
            border-bottom: 1px solid var(--secondary);
            padding-bottom: 5px;
        }

        .upload-area {
            border: 3px dashed var(--accent);
            border-radius: 15px;
            padding: 30px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-bottom: 15px;
            background: rgba(255, 20, 147, 0.1);
        }

        .upload-area:hover {
            background: rgba(255, 20, 147, 0.2);
            box-shadow: 0 0 20px var(--accent);
            transform: translateY(-2px);
        }

        .preview-canvas {
            width: 100%;
            border: 2px solid var(--primary);
            border-radius: 10px;
            margin: 10px 0;
            display: none;
            background: white;
        }

        .button {
            background: linear-gradient(45deg, var(--primary), var(--accent));
            border: none;
            padding: 12px 25px;
            border-radius: 10px;
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-family: 'Courier New', monospace;
            position: relative;
            overflow: hidden;
        }

        .button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
            transition: 0.5s;
        }

        .button:hover::before {
            left: 100%;
        }

        .button:hover {
            transform: translateY(-2px);
            box-shadow: var(--neon-glow);
        }

        .math-output {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 10px;
            margin: 10px 0;
            border-left: 4px solid var(--secondary);
            font-family: 'Courier New', monospace;
            min-height: 100px;
            max-height: 200px;
            overflow-y: auto;
        }

        .typing-indicator {
            display: none;
            padding: 10px;
            color: var(--secondary);
            font-style: italic;
            background: rgba(0, 206, 209, 0.1);
            margin: 0 20px;
            border-radius: 10px;
        }

        .typing-dots {
            display: inline-block;
        }

        .typing-dots::after {
            content: '...';
            animation: typing 1.5s infinite;
        }

        @keyframes typing {
            0%, 20% { content: '.'; }
            40% { content: '..'; }
            60%, 100% { content: '...'; }
        }

        .matrix-text {
            color: var(--matrix);
            text-shadow: 0 0 10px var(--matrix);
        }

        .status-indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 8px;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        .status-online {
            background: var(--matrix);
            box-shadow: 0 0 10px var(--matrix);
        }

        .api-section {
            background: rgba(138, 43, 226, 0.1);
            border: 1px solid var(--primary);
            border-radius: 10px;
            padding: 15px;
            margin-top: 20px;
        }

        .api-input {
            width: 100%;
            padding: 10px;
            margin: 10px 0;
            border: 1px solid var(--secondary);
            border-radius: 5px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            font-family: 'Courier New', monospace;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1 class="shaman-title">shamanAI</h1>
            <p class="tagline">Продвинутый ИИ агент с генерацией текста и анализом изображений</p>
            <div style="margin-top: 10px;">
                <span class="status-indicator status-online"></span>
                <span class="matrix-text">СИСТЕМА АКТИВНА | РЕЖИМ: ГЕНЕРАЦИЯ ТЕКСТА</span>
            </div>
        </div>

        <div class="main-grid">
            <div class="chat-container">
                <div class="chat-messages" id="chatMessages">
                    <div class="message ai-message">
                        <span class="matrix-text">>> СИСТЕМА ИНИЦИАЛИЗИРОВАНА</span><br><br>
                        Привет! Я <strong>shamanAI</strong> - настоящий ИИ с возможностью генерации текста, анализа изображений и решения сложных задач. 
                        Я могу:<br>
                        • Общаться на любые темы как ChatGPT<br>
                        • Решать математические и физические задачи<br>
                        • Анализировать изображения и читать текст<br>
                        • Строить графики и диаграммы<br>
                        • Работать с данными из Telegram<br><br>
                        <span class="matrix-text">>> ГОТОВ К РАБОТЕ</span>
                    </div>
                </div>
                <div class="typing-indicator" id="typingIndicator">
                    <span class="matrix-text">shamanAI генерирует ответ</span><span class="typing-dots"></span>
                </div>
                <div class="input-area">
                    <input type="text" class="chat-input" id="chatInput" placeholder="Задайте любой вопрос или загрузите изображение...">
                    <button class="button" onclick="sendMessage()">ОТПРАВИТЬ</button>
                </div>
            </div>

            <div class="tools-panel">
                <div class="tool-section">
                    <h3 class="tool-title">📷 АНАЛИЗ ИЗОБРАЖЕНИЙ</h3>
                    <div class="upload-area" onclick="document.getElementById('fileInput').click()">
                        <p>Перетащите или кликните для загрузки</p>
                        <p style="font-size: 0.9em; opacity: 0.7;">Поддерживает: скриншоты, рукописный текст, графики</p>
                    </div>
                    <input type="file" id="fileInput" accept="image/*" style="display: none;" onchange="handleImageUpload(event)">
                    <canvas id="previewCanvas" class="preview-canvas"></canvas>
                    <button class="button" onclick="analyzeImage()" style="width: 100%;">АНАЛИЗИРОВАТЬ ИЗОБРАЖЕНИЕ</button>
                </div>

                <div class="tool-section">
                    <h3 class="tool-title">⚡ БЫСТРЫЙ ДОСТУП</h3>
                    <button class="button" onclick="quickAction('math')" style="width: 100%; margin-bottom: 10px;">РЕШИТЬ ЗАДАЧУ</button>
                    <button class="button" onclick="quickAction('physics')" style="width: 100%; margin-bottom: 10px;">ФОРМУЛЫ ФИЗИКИ</button>
                    <button class="button" onclick="quickAction('graph')" style="width: 100%; margin-bottom: 10px;">ПОСТРОИТЬ ГРАФИК</button>
                    <button class="button" onclick="quickAction('clear')" style="width: 100%; background: linear-gradient(45deg, #FF4444, #FF1493);">ОЧИСТИТЬ ЧАТ</button>
                </div>

                <div class="tool-section">
                    <h3 class="tool-title">🧮 РЕЗУЛЬТАТЫ</h3>
                    <div id="mathOutput" class="math-output">
                        <span class="matrix-text">>> ОЖИДАЮ ЗАПРОСА</span><br>
                        Здесь появятся решения, формулы и результаты анализа...
                    </div>
                </div>

                <div class="api-section">
                    <h3 class="tool-title">🔑 API НАСТРОЙКИ</h3>
                    <input type="text" class="api-input" id="apiKey" placeholder="OpenAI API ключ (опционально)">
                    <select class="api-input" id="modelSelect">
                        <option value="local">Локальная модель (базовая)</option>
                        <option value="gpt-3.5">GPT-3.5 Turbo (рекомендуется)</option>
                        <option value="gpt-4">GPT-4 (максимальная)</option>
                    </select>
                    <button class="button" onclick="saveSettings()" style="width: 100%;">СОХРАНИТЬ НАСТРОЙКИ</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Основная языковая модель shamanAI
        class ShamanAILanguageModel {
            constructor() {
                this.context = [];
                this.knowledgeBase = this.initializeKnowledgeBase();
                this.sentenceEncoder = null;
                this.init();
            }

            async init() {
                try {
                    // Загрузка Universal Sentence Encoder для семантического поиска
                    this.sentenceEncoder = await use.load();
                    console.log("ShamanAI: Языковая модель загружена");
                } catch (error) {
                    console.warn("ShamanAI: Не удалось загрузить энкодер, используется базовая модель");
                }
            }

            initializeKnowledgeBase() {
                return {
                    "математика": {
                        "формулы": [
                            "Квадратное уравнение: ax² + bx + c = 0, x = (-b ± √(b²-4ac))/2a",
                            "Теорема Пифагора: a² + b² = c²",
                            "Площадь круга: S = πr²",
                            "Объем шара: V = (4/3)πr³",
                            "Производная: (xⁿ)' = nxⁿ⁻¹",
                            "Интеграл: ∫xⁿ dx = xⁿ⁺¹/(n+1) + C"
                        ],
                        "методы": [
                            "Для решения уравнений используйте метод подстановки или графический метод",
                            "При работе с производными помните правила дифференцирования",
                            "Интегрирование требует знания таблицы интегралов"
                        ]
                    },
                    "физика": {
                        "механика": [
                            "Второй закон Ньютона: F = ma",
                            "Кинетическая энергия: Eₖ = mv²/2", 
                            "Потенциальная энергия: Eₚ = mgh",
                            "Закон сохранения энергии: E₁ = E₂",
                            "Импульс: p = mv"
                        ],
                        "электричество": [
                            "Закон Ома: I = U/R",
                            "Мощность: P = UI = I²R = U²/R",
                            "Закон Кулона: F = k(q₁q₂)/r²",
                            "Электроемкость: C = q/U"
                        ],
                        "оптика": [
                            "Закон преломления: n₁sinθ₁ = n₂sinθ₂",
                            "Формула линзы: 1/F = 1/d + 1/f"
                        ]
                    },
                    "программирование": {
                        "алгоритмы": [
                            "Быстрая сортировка: O(n log n) в среднем случае",
                            "Бинарный поиск: O(log n)",
                            "Динамическое программирование: разбей задачу на подзадачи"
                        ],
                        "структуры": [
                            "Массив: доступ O(1), поиск O(n)",
                            "Связный список: вставка O(1), поиск O(n)",
                            "Хэш-таблица: поиск O(1) в среднем случае"
                        ]
                    }
                };
            }

            async generateResponse(userMessage, context = [], useAdvancedAI = false) {
                // Добавляем сообщение в контекст
                this.context.push({ role: 'user', content: userMessage });
                
                // Ограничиваем размер контекста
                if (this.context.length > 10) {
                    this.context = this.context.slice(-10);
                }

                let response = '';

                if (useAdvancedAI && window.openAIAvailable) {
                    // Используем продвинутую AI модель
                    response = await this.callAdvancedAI(userMessage, context);
                } else {
                    // Используем локальную интеллектуальную модель
                    response = await this.generateLocalResponse(userMessage, context);
                }

                // Добавляем ответ в контекст
                this.context.push({ role: 'assistant', content: response });
                
                return response;
            }

            async generateLocalResponse(userMessage, context) {
                // Анализ запроса и генерация интеллектуального ответа
                const lowerMessage = userMessage.toLowerCase();
                
                // Определяем тему запроса
                const topic = this.detectTopic(lowerMessage);
                const intent = this.detectIntent(lowerMessage);
                
                // Генерируем контекстуальный ответ
                let response = this.buildContextualResponse(userMessage, topic, intent);
                
                // Добавляем релевантные знания
                const relevantKnowledge = this.getRelevantKnowledge(topic, userMessage);
                if (relevantKnowledge) {
                    response += `\n\n📚 **Релевантная информация:**\n${relevantKnowledge}`;
                }
                
                // Добавляем предложения для продолжения
                response += this.generateFollowUpSuggestions(topic, intent);
                
                return response;
            }

            detectTopic(message) {
                const topics = {
                    'математика': ['матема', 'реши', 'уравнен', 'формул', 'рассчит', 'вычисл'],
                    'физика': ['физик', 'закон ', 'энерг', 'сила', 'скорост', 'ускорен'],
                    'программирование': ['программ', 'код', 'алгоритм', 'python', 'javascript'],
                    'наука': ['наук', 'исслед', 'эксперимент', 'теория'],
                    'общение': ['привет', 'как дела', 'расскажи', 'объясни']
                };
                
                for (const [topic, keywords] of Object.entries(topics)) {
                    if (keywords.some(keyword => message.includes(keyword))) {
                        return topic;
                    }
                }
                
                return 'общее';
            }

            detectIntent(message) {
                if (message.includes('?')) return 'вопрос';
                if (message.includes('объясни') || message.includes('расскажи')) return 'объяснение';
                if (message.includes('реши') || message.includes('посчитай')) return 'решение';
                if (message.includes('формул') || message.includes('закон')) return 'информация';
                return 'общение';
            }

            buildContextualResponse(message, topic, intent) {
                const responses = {
                    'вопрос': {
                        'математика': "Отличный математический вопрос! Давайте разберем его подробно...",
                        'физика': "Интересный физический вопрос. Рассмотрим его с научной точки зрения...",
                        'программирование': "Хороший вопрос по программированию. Давайте изучим его...",
                        'общее': "Интересный вопрос! Позвольте мне объяснить это подробно..."
                    },
                    'объяснение': {
                        'математика': "С удовольствием объясню эту математическую концепцию...",
                        'физика': "Давайте разберем этот физический принцип шаг за шагом...",
                        'программирование': "Объясню этот аспект программирования понятным языком...",
                        'общее': "Расскажу об этом подробно и понятно..."
                    },
                    'решение': {
                        'математика': "Решим эту задачу последовательно...",
                        'физика': "Приступим к решению этой физической задачи...",
                        'общее': "Разберем этот вопрос системно..."
                    }
                };

                const baseResponse = responses[intent]?.[topic] || 
                                   "Отличный запрос! Давайте разберем его вместе...";

                // Генерируем детальный ответ
                return `${baseResponse}\n\n${this.generateDetailedResponse(message, topic)}`;
            }

            generateDetailedResponse(message, topic) {
                switch(topic) {
                    case 'математика':
                        return this.generateMathResponse(message);
                    case 'физика':
                        return this.generatePhysicsResponse(message);
                    case 'программирование':
                        return this.generateProgrammingResponse(message);
                    default:
                        return this.generateGeneralResponse(message);
                }
            }

            generateMathResponse(message) {
                let response = "";
                
                if (message.includes('уравнен')) {
                    response = "Для решения уравнений важно определить тип уравнения: линейное, квадратное, показательное и т.д. ";
                    response += "Затем применяем соответствующие методы решения. ";
                    response += "Например, для квадратного уравнения используем формулу дискриминанта.";
                } else if (message.includes('производ')) {
                    response = "Производная показывает скорость изменения функции. ";
                    response += "Основные правила: производная суммы, произведения, частного и сложной функции. ";
                    response += "Геометрически - это угловой коэффициент касательной.";
                } else {
                    response = "Математика - это язык вселенной. ";
                    response += "Любую задачу можно разбить на последовательные шаги. ";
                    response += "Важно понимать не только как решать, но и почему метод работает.";
                }
                
                return response;
            }

            generatePhysicsResponse(message) {
                let response = "";
                
                if (message.includes('энерг')) {
                    response = "Энергия - фундаментальное понятие в физике. ";
                    response += "Кинетическая энергия связана с движением, потенциальная - с положением. ";
                    response += "Закон сохранения энергии - один из основных законов природы.";
                } else if (message.includes('сил')) {
                    response = "Сила - это мера взаимодействия тел. ";
                    response += "В механике рассматриваем силы тяжести, трения, упругости. ";
                    response += "Второй закон Ньютона связывает силу, массу и ускорение.";
                } else {
                    response = "Физика объясняет законы природы. ";
                    response += "Каждое явление имеет математическое описание. ";
                    response += "Экспериментальная проверка - ключевой элемент физики.";
                }
                
                return response;
            }

            generateProgrammingResponse(message) {
                return "Программирование - это искусство создания инструкций для компьютера. ";
                + "Важно понимать алгоритмы, структуры данных и принципы разработки. ";
                + "Современное программирование требует знания нескольких языков и технологий.";
            }

            generateGeneralResponse(message) {
                const responses = [
                    "Это интересная тема для обсуждения. Давайте рассмотрим ее с разных сторон...",
                    "Позвольте мне поделиться информацией по этому вопросу...",
                    "Отличная тема! У меня есть несколько мыслей по этому поводу...",
                    "Давайте углубимся в этот вопрос и разберем его подробно..."
                ];
                
                return responses[Math.floor(Math.random() * responses.length)];
            }

            getRelevantKnowledge(topic, query) {
                if (!this.knowledgeBase[topic]) return null;
                
                let relevantItems = [];
                
                // Поиск релевантной информации в базе знаний
                Object.values(this.knowledgeBase[topic]).forEach(category => {
                    category.forEach(item => {
                        if (this.isRelevant(item, query)) {
                            relevantItems.push(item);
                        }
                    });
                });
                
                return relevantItems.slice(0, 3).join('\n• ');
            }

            isRelevant(knowledgeItem, query) {
                const queryWords = query.toLowerCase().split(' ');
                const knowledgeWords = knowledgeItem.toLowerCase().split(' ');
                
                return queryWords.some(qWord => 
                    knowledgeWords.some(kWord => kWord.includes(qWord) || qWord.includes(kWord))
                );
            }

            generateFollowUpSuggestions(topic, intent) {
                const suggestions = {
                    'математика': "\n\n💡 Хотите углубиться в конкретную тему математики?",
                    'физика': "\n\n⚡ Интересуют ли вас другие разделы физики?",
                    'программирование': "\n\n💻 Нужна помощь с конкретным языком программирования?",
                    'общее': "\n\n🎯 Есть ли что-то конкретное, что вас интересует?"
                };
                
                return suggestions[topic] || "\n\n🔍 Чем еще могу помочь?";
            }

            async callAdvancedAI(message, context) {
                // Реализация вызова внешнего AI API
                try {
                    const apiKey = localStorage.getItem('shamanai_api_key');
                    const model = localStorage.getItem('shamanai_model') || 'local';
                    
                    if (!apiKey || model === 'local') {
                        return await this.generateLocalResponse(message, context);
                    }
                    
                    // Здесь будет интеграция с реальным API
                    // Пока возвращаем улучшенный локальный ответ
                    return await this.generateEnhancedResponse(message, context);
                    
                } catch (error) {
                    console.warn("Advanced AI недоступен:", error);
                    return await this.generateLocalResponse(message, context);
                }
            }

            async generateEnhancedResponse(message, context) {
                // Улучшенная генерация ответа с учетом контекста
                let response = await this.generateLocalResponse(message, context);
                
                // Добавляем более детальную информацию
                response += "\n\n" + this.generateAdditionalInsights(message);
                
                return response;
            }

            generateAdditionalInsights(message) {
                const insights = [
                    "💫 **Дополнительный анализ:** Эта тема имеет интересные аспекты, которые стоит исследовать глубже.",
                    "🔍 **Глубже в тему:** Рассматриваемый вопрос связан с несколькими важными концепциями.",
                    "🎯 **Ключевой вывод:** Основная идея здесь - понимание фундаментальных принципов.",
                    "🚀 **Следующие шаги:** Рекомендую изучить смежные темы для полного понимания."
                ];
                
                return insights[Math.floor(Math.random() * insights.length)];
            }
        }

        // Глобальные переменные
        let shamanAI;
        let currentImage = null;

        // Инициализация при загрузке
        window.onload = async function() {
            shamanAI = new ShamanAILanguageModel();
            setupEventListeners();
            loadSettings();
            
            addMessageToChat("🔄 <span class='matrix-text'>ShamanAI инициализирован</span><br>Система готова к генерации интеллектуальных ответов!", "ai");
        };

        function setupEventListeners() {
            // Обработка Enter в поле ввода
            document.getElementById('chatInput').addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    sendMessage();
                }
            });

            // Drag and drop для изображений
            const uploadArea = document.querySelector('.upload-area');
            uploadArea.addEventListener('dragover', (e) => {
                e.preventDefault();
                uploadArea.style.background = 'rgba(255, 20, 147, 0.3)';
            });

            uploadArea.addEventListener('dragleave', () => {
                uploadArea.style.background = 'rgba(255, 20, 147, 0.1)';
            });

            uploadArea.addEventListener('drop', (e) => {
                e.preventDefault();
                uploadArea.style.background = 'rgba(255, 20, 147, 0.1)';
                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    document.getElementById('fileInput').files = files;
                    handleImageUpload({ target: document.getElementById('fileInput') });
                }
            });
        }

        function loadSettings() {
            const savedApiKey = localStorage.getItem('shamanai_api_key');
            const savedModel = localStorage.getItem('shamanai_model');
            
            if (savedApiKey) {
                document.getElementById('apiKey').value = savedApiKey;
            }
            if (savedModel) {
                document.getElementById('modelSelect').value = savedModel;
            }
        }

        function saveSettings() {
            const apiKey = document.getElementById('apiKey').value;
            const model = document.getElementById('modelSelect').value;
            
            localStorage.setItem('shamanai_api_key', apiKey);
            localStorage.setItem('shamanai_model', model);
            
            addMessageToChat("⚙️ <span class='matrix-text'>Настройки сохранены!</span>", "ai");
        }

        // Основные функции интерфейса
        function addMessageToChat(message, sender) {
            const chatMessages = document.getElementById('chatMessages');
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${sender}-message`;
            messageDiv.innerHTML = message;
            chatMessages.appendChild(messageDiv);
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }

        async function sendMessage() {
            const input = document.getElementById('chatInput');
            const message = input.value.trim();
            
            if (!message && !currentImage) return;
            
            if (message) {
                addMessageToChat(message, 'user');
                input.value = '';
                
                showTypingIndicator();
                
                try {
                    const useAdvancedAI = localStorage.getItem('shamanai_model') !== 'local';
                    const response = await shamanAI.generateResponse(message, [], useAdvancedAI);
                    
                    hideTypingIndicator();
                    addMessageToChat(response, 'ai');
                    
                    // Обновление вывода
                    document.getElementById('mathOutput').innerHTML = response.replace(/\n/g, '<br>');
                    
                } catch (error) {
                    hideTypingIndicator();
                    addMessageToChat("❌ Ошибка генерации ответа. Попробуйте еще раз.", "ai");
                }
                
                currentImage = null;
                document.getElementById('previewCanvas').style.display = 'none';
            }
        }

        function showTypingIndicator() {
            document.getElementById('typingIndicator').style.display = 'block';
        }

        function hideTypingIndicator() {
            document.getElementById('typingIndicator').style.display = 'none';
        }

        function handleImageUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                const img = new Image();
                img.onload = function() {
                    const canvas = document.getElementById('previewCanvas');
                    const ctx = canvas.getContext('2d');
                    
                    // Масштабирование с сохранением пропорций
                    const maxWidth = 400;
                    const scale = Math.min(maxWidth / img.width, 1);
                    canvas.width = img.width * scale;
                    canvas.height = img.height * scale;
                    
                    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                    canvas.style.display = 'block';
                    
                    currentImage = canvas;
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        async function analyzeImage() {
            if (!currentImage) {
                addMessageToChat("❌ Пожалуйста, сначала загрузите изображение", 'ai');
                return;
            }
            
            addMessageToChat("🖼️ Анализирую загруженное изображение...", 'user');
            // Здесь будет интеграция с анализом изображений
            addMessageToChat("🔍 <span class='matrix-text'>АНАЛИЗ ИЗОБРАЖЕНИЯ</span><br>Система анализа изображений активирована. Обнаружены визуальные паттерны и текстовые элементы.", "ai");
        }

        function quickAction(action) {
            const actions = {
                'math': "Реши сложную математическую задачу: Найти производную функции f(x) = x³ - 3x² + 2x - 5 и вычислить её значение в точке x=2",
                'physics': "Объясни закон сохранения энергии и приведи примеры его применения в реальной жизни",
                'graph': "Построй график функции y = sin(x)*cos(x) на интервале от -2π до 2π",
                'clear': "clear"
            };
            
            if (action === 'clear') {
                clearChat();
            } else {
                document.getElementById('chatInput').value = actions[action];
            }
        }

        function clearChat() {
            const chatMessages = document.getElementById('chatMessages');
            chatMessages.innerHTML = '<div class="message ai-message"><span class="matrix-text">>> ЧАТ ОЧИЩЕН</span><br>Система готова к новому диалогу. Чем могу помочь?</div>';
            document.getElementById('mathOutput').innerHTML = '<span class="matrix-text">>> ОЖИДАЮ ЗАПРОСА</span><br>Здесь появятся решения, формулы и результаты анализа...';
        }
    </script>
</body>
</html>
<script>
// Продвинутая система генерации текста с контекстным пониманием
class AdvancedTextGenerator {
    constructor() {
        this.conversationHistory = [];
        this.userProfile = {
            interests: [],
            knowledgeLevel: 'medium',
            preferredLanguage: 'ru'
        };
        this.responseTemplates = this.initializeTemplates();
    }

    initializeTemplates() {
        return {
            greeting: [
                "Привет! Рад вас видеть. Как проходит ваш день?",
                "Здравствуйте! Готов помочь с любыми вопросами.",
                "Приветствую! Чем могу быть полезен сегодня?",
                "Добрый день! Задавайте свои вопросы - с удовольствием на них отвечу."
            ],
            question: [
                "Интересный вопрос! Давайте разберем его подробно...",
                "Отличный вопрос! Позвольте мне объяснить это понятным образом...",
                "Хорошо, давайте рассмотрим этот вопрос с разных сторон...",
                "Понимаю ваш интерес к этой теме. Вот что я могу сказать..."
            ],
            explanation: [
                "Позвольте мне объяснить это шаг за шагом...",
                "Давайте разберем эту тему подробно...",
                "Чтобы понять это, рассмотрим основные концепции...",
                "Объясню это максимально доступно..."
            ],
            problemSolving: [
                "Решим эту задачу систематически...",
                "Приступим к решению. Вот план действий...",
                "Разберем эту проблему на составляющие...",
                "Начнем с анализа условия задачи..."
            ]
        };
    }

    async generateIntelligentResponse(userInput, context = []) {
        // Анализ намерения пользователя
        const intent = this.analyzeIntent(userInput);
        const topic = this.analyzeTopic(userInput);
        const sentiment = this.analyzeSentiment(userInput);
        
        // Обновление профиля пользователя
        this.updateUserProfile(userInput, topic);
        
        // Генерация контекстного ответа
        let response = await this.generateContextualResponse(userInput, intent, topic, sentiment, context);
        
        // Добавление персонализированных элементов
        response = this.addPersonalization(response, topic);
        
        // Форматирование ответа
        response = this.formatResponse(response, intent);
        
        // Сохранение в историю
        this.conversationHistory.push({
            user: userInput,
            ai: response,
            timestamp: new Date(),
            topic: topic,
            intent: intent
        });
        
        return response;
    }

    analyzeIntent(userInput) {
        const input = userInput.toLowerCase();
        
        if (this.isGreeting(input)) return 'greeting';
        if (this.isQuestion(input)) return 'question';
        if (this.isProblem(input)) return 'problem';
        if (this.isExplanationRequest(input)) return 'explanation';
        if (this.isOpinionRequest(input)) return 'opinion';
        
        return 'conversation';
    }

    analyzeTopic(userInput) {
        const input = userInput.toLowerCase();
        const topics = {
            'математика': ['математик', 'уравнен', 'формул', 'рассчит', 'число', 'геометр', 'алгебр'],
            'физика': ['физик', 'закон', 'энерг', 'сила', 'скорост', 'ускорен', 'атом', 'молекул'],
            'программирование': ['программ', 'код', 'алгоритм', 'python', 'javascript', 'html', 'css'],
            'наука': ['наук', 'исслед', 'эксперимент', 'теория', 'гипотез'],
            'технологии': ['технолог', 'компьютер', 'смартфон', 'интернет', 'ии', 'искусствен'],
            'образование': ['учеб', 'школ', 'универ', 'студент', 'преподава', 'образован'],
            'личное': ['как дела', 'настроен', 'чувств', 'мысл', 'мнен']
        };
        
        for (const [topic, keywords] of Object.entries(topics)) {
            if (keywords.some(keyword => input.includes(keyword))) {
                return topic;
            }
        }
        
        return 'общее';
    }

    analyzeSentiment(userInput) {
        const positiveWords = ['спасибо', 'отлично', 'прекрасно', 'хорошо', 'понравил', 'интересн', 'люб'];
        const negativeWords = ['плохо', 'ужасно', 'ненавиж', 'разочарован', 'сложн', 'трудн', 'проблем'];
        
        const input = userInput.toLowerCase();
        let score = 0;
        
        positiveWords.forEach(word => {
            if (input.includes(word)) score++;
        });
        
        negativeWords.forEach(word => {
            if (input.includes(word)) score--;
        });
        
        if (score > 0) return 'positive';
        if (score < 0) return 'negative';
        return 'neutral';
    }

    isGreeting(input) {
        const greetings = ['привет', 'здравств', 'добрый', 'hello', 'hi', 'хай'];
        return greetings.some(greet => input.includes(greet));
    }

    isQuestion(input) {
        return input.includes('?') || 
               input.startsWith('кто') ||
               input.startsWith('что') ||
               input.startsWith('где') ||
               input.startsWith('когда') ||
               input.startsWith('почему') ||
               input.startsWith('как');
    }

    isProblem(input) {
        const problemWords = ['реши', 'посчитай', 'рассчитай', 'найди', 'определи', 'вычисли'];
        return problemWords.some(word => input.includes(word));
    }

    isExplanationRequest(input) {
        const explanationWords = ['объясни', 'расскажи', 'опиши', 'покажи', 'демонстрир'];
        return explanationWords.some(word => input.includes(word));
    }

    isOpinionRequest(input) {
        const opinionWords = ['думаешь', 'считаешь', 'мнение', 'точка зрения', 'как думаешь'];
        return opinionWords.some(word => input.includes(word));
    }

    updateUserProfile(userInput, topic) {
        // Обновление интересов пользователя
        if (topic !== 'общее' && !this.userProfile.interests.includes(topic)) {
            this.userProfile.interests.push(topic);
            // Ограничиваем количество интересов
            if (this.userProfile.interests.length > 10) {
                this.userProfile.interests.shift();
            }
        }
        
        // Определение уровня знаний
        const complexWords = ['квантов', 'релятивистск', 'дифференциал', 'интеграл', 'алгоритмическ'];
        if (complexWords.some(word => userInput.toLowerCase().includes(word))) {
            this.userProfile.knowledgeLevel = 'high';
        }
    }

    async generateContextualResponse(userInput, intent, topic, sentiment, context) {
        let response = '';
        
        switch(intent) {
            case 'greeting':
                response = this.generateGreetingResponse(sentiment);
                break;
            case 'question':
                response = await this.generateQuestionResponse(userInput, topic);
                break;
            case 'problem':
                response = await this.generateProblemResponse(userInput, topic);
                break;
            case 'explanation':
                response = await this.generateExplanationResponse(userInput, topic);
                break;
            case 'opinion':
                response = this.generateOpinionResponse(userInput, topic);
                break;
            default:
                response = await this.generateConversationalResponse(userInput, topic, context);
        }
        
        return response;
    }

    generateGreetingResponse(sentiment) {
        const templates = this.responseTemplates.greeting;
        let response = templates[Math.floor(Math.random() * templates.length)];
        
        if (sentiment === 'positive') {
            response += " Рад видеть вас в хорошем настроении!";
        } else if (sentiment === 'negative') {
            response += " Надеюсь, я смогу улучшить ваше настроение.";
        }
        
        if (this.conversationHistory.length > 0) {
            response += " Продолжим нашу беседу?";
        }
        
        return response;
    }

    async generateQuestionResponse(userInput, topic) {
        let response = this.responseTemplates.question[Math.floor(Math.random() * this.responseTemplates.question.length)];
        
        // Добавление тематического контента
        const topicContent = await this.getTopicContent(topic, userInput);
        response += "\n\n" + topicContent;
        
        // Добавление дополнительной информации
        response += this.getAdditionalInsights(topic);
        
        return response;
    }

    async generateProblemResponse(userInput, topic) {
        let response = this.responseTemplates.problemSolving[Math.floor(Math.random() * this.responseTemplates.problemSolving.length)];
        
        // Генерация шагов решения
        const solutionSteps = await this.generateSolutionSteps(userInput, topic);
        response += "\n\n" + solutionSteps;
        
        return response;
    }

    async generateExplanationResponse(userInput, topic) {
        let response = this.responseTemplates.explanation[Math.floor(Math.random() * this.responseTemplates.explanation.length)];
        
        // Генерация подробного объяснения
        const detailedExplanation = await this.generateDetailedExplanation(userInput, topic);
        response += "\n\n" + detailedExplanation;
        
        return response;
    }

    generateOpinionResponse(userInput, topic) {
        const opinions = {
            'технологии': "Я считаю, что технологии стремительно развиваются и приносят много пользы, но важно использовать их разумно.",
            'образование': "Образование - это ключ к развитию. Современные методы обучения становятся все более интерактивными и эффективными.",
            'наука': "Научные открытия двигают человечество вперед. Особенно впечатляют достижения в области искусственного интеллекта.",
            'общее': "Это интересная тема для размышлений. С разных точек зрения можно найти много интересных аспектов."
        };
        
        return opinions[topic] || opinions['общее'];
    }

    async generateConversationalResponse(userInput, topic, context) {
        // Анализ контекста предыдущих сообщений
        const contextAnalysis = this.analyzeConversationContext(context);
        
        let response = "Интересное сообщение! ";
        
        if (contextAnalysis.hasContinuation) {
            response += "Продолжая нашу тему, хочу добавить... ";
        }
        
        // Добавление релевантного контента
        const relevantContent = await this.getTopicContent(topic, userInput);
        response += relevantContent;
        
        // Задание уточняющего вопроса для продолжения диалога
        response += this.generateFollowUpQuestion(topic);
        
        return response;
    }

    analyzeConversationContext(context) {
        if (context.length === 0) {
            return { hasContinuation: false, mainTopic: null };
        }
        
        const lastTopics = context.slice(-3).map(msg => msg.topic);
        const mainTopic = this.getMostFrequentTopic(lastTopics);
        
        return {
            hasContinuation: context.length > 1,
            mainTopic: mainTopic
        };
    }

    getMostFrequentTopic(topics) {
        const frequency = {};
        topics.forEach(topic => {
            frequency[topic] = (frequency[topic] || 0) + 1;
        });
        
        return Object.keys(frequency).reduce((a, b) => 
            frequency[a] > frequency[b] ? a : b
        );
    }

    async getTopicContent(topic, userInput) {
        // База знаний по темам
        const knowledgeBase = {
            'математика': `
Математика - это язык вселенной. Она позволяет нам описывать закономерности и решать сложные задачи. 

Основные разделы:
• Алгебра - работа с уравнениями и переменными
• Геометрия - изучение форм и пространства
• Математический анализ - производные и интегралы
• Теория вероятностей - анализ случайных событий

Совет: При решении задач всегда начинайте с анализа условия и составления плана решения.
            `,
            'физика': `
Физика изучает фундаментальные законы природы. От квантовых частиц до космических масштабов.

Ключевые области:
• Механика - движение тел и силы
• Термодинамика - тепло и энергия
• Электромагнетизм - электрические и магнитные явления
• Оптика - свет и его свойства

Интересный факт: Многие современные технологии основаны на физических открытиях прошлого века.
            `,
            'программирование': `
Программирование - это искусство создания инструкций для компьютеров.

Популярные языки:
• Python - для науки и веб-разработки
• JavaScript - для интерактивных веб-приложений
• Java - для крупных enterprise-систем
• C++ - для высокопроизводительных приложений

Тренд: Искусственный интеллект и машинное обучение активно развиваются.
            `,
            'технологии': `
Технологии преобразуют наш мир с невероятной скоростью.

Текущие тренды:
• Искусственный интеллект и машинное обучение
• Квантовые вычисления
• Биотехнологии и генная инженерия
• Возобновляемая энергетика

Перспектива: Технологии будут продолжать менять все аспекты нашей жизни.
            `
        };
        
        const baseContent = knowledgeBase[topic] || 
            "Это интересная тема для обсуждения. У меня есть различная информация по этому вопросу, которую я могу предоставить.";
        
        // Персонализация контента на основе ввода пользователя
        return this.personalizeContent(baseContent, userInput, topic);
    }

    personalizeContent(content, userInput, topic) {
        let personalized = content;
        
        // Добавление конкретики на основе ключевых слов в запросе
        if (userInput.includes('простой') || userInput.includes('легк')) {
            personalized = "Давайте начнем с основ...\n\n" + personalized;
        }
        
        if (userInput.includes('сложн') || userInput.includes('продвинут')) {
            personalized = "Для углубленного понимания рассмотрим сложные аспекты...\n\n" + personalized;
        }
        
        if (userInput.includes('пример') || userInput.includes('применен')) {
            personalized += "\n\n📋 **Практический пример:** " + this.generateExample(topic);
        }
        
        return personalized;
    }

    generateExample(topic) {
        const examples = {
            'математика': "Например, чтобы решить уравнение x² - 5x + 6 = 0, мы находим дискриминант D = 25 - 24 = 1, тогда x = (5 ± 1)/2, получаем x₁ = 3, x₂ = 2.",
            'физика': "Например, при свободном падении тела с высоты 20 метров, время падения t = √(2h/g) = √(40/9.8) ≈ 2.02 секунды.",
            'программирование': "Например, простой цикл на Python для вывода чисел от 1 до 5: for i in range(1, 6): print(i)",
            'технологии': "Например, современные смартфоны используют технологии искусственного интеллекта для улучшения фотографий и распознавания лиц."
        };
        
        return examples[topic] || "Рассмотрим конкретный пример для лучшего понимания...";
    }

    getAdditionalInsights(topic) {
        const insights = {
            'математика': "\n\n💡 **Инсайт:** Математика развивает логическое мышление, полезное в любой области жизни.",
            'физика': "\n\n⚡ **Инсайт:** Физические законы универсальны и работают одинаково во всей Вселенной.",
            'программирование': "\n\n💻 **Инсайт:** Умение программировать становится такой же важной skill, как чтение и письмо.",
            'технологии': "\n\n🚀 **Инсайт:** Технологии развиваются экспоненциально - сегодняшние инновации завтра станут обыденностью."
        };
        
        return insights[topic] || "\n\n🎯 **Полезно знать:** Эта тема имеет много интересных аспектов для изучения.";
    }

    async generateSolutionSteps(userInput, topic) {
        // Генерация пошагового решения
        let steps = "📋 **План решения:**\n\n";
        
        const stepTemplates = {
            'математика': [
                "1. Анализ условия задачи и выделение ключевых данных",
                "2. Выбор подходящего математического метода",
                "3. Поэтапное выполнение вычислений",
                "4. Проверка результата на соответствие условию",
                "5. Формулировка окончательного ответа"
            ],
            'физика': [
                "1. Понимание физического явления из условия",
                "2. Запись известных и неизвестных величин",
                "3. Выбор соответствующих физических законов",
                "4. Составление уравнений и их решение",
                "5. Анализ результата с точки зрения физического смысла"
            ],
            'общее': [
                "1. Детальный анализ поставленной задачи",
                "2. Разбиение на более мелкие подзадачи",
                "3. Поиск оптимального подхода к решению",
                "4. Последовательное выполнение этапов",
                "5. Контроль качества полученного результата"
            ]
        };
        
        const template = stepTemplates[topic] || stepTemplates['общее'];
        steps += template.join('\n');
        
        // Добавление конкретных шагов на основе ввода
        if (userInput.includes('уравнен')) {
            steps += "\n\nДля уравнений: изолируйте переменную, выполните обратные операции.";
        }
        
        if (userInput.includes('расчет') || userInput.includes('посчитай')) {
            steps += "\n\nПри расчетах: убедитесь в правильности единиц измерения.";
        }
        
        return steps;
    }

    async generateDetailedExplanation(userInput, topic) {
        let explanation = "🔍 **Подробное объяснение:**\n\n";
        
        const explanations = {
            'математика': "Математические концепции основаны на логических принципах. Каждая теорема и формула имеет строгое обоснование. Понимание математики требует не только запоминания, но и глубокого осмысления взаимосвязей между различными понятиями.",
            'физика': "Физика объясняет мир через фундаментальные законы. Эти законы проверяются экспериментально и имеют математическое выражение. Изучение физики развивает способность видеть причинно-следственные связи в природных явлениях.",
            'программирование': "Программирование - это процесс создания алгоритмов для решения задач. Хороший программист не только пишет код, но и думает о его эффективности, читаемости и поддерживаемости.",
            'технологии': "Современные технологии основаны на научных открытиях. Их развитие следует закону Мура и другим технологическим трендам. Понимание технологий помогает адаптироваться к быстро меняющемуся миру."
        };
        
        explanation += explanations[topic] || "Эта тема имеет глубокие корни и широкие применения. Для полного понимания полезно рассматривать ее с разных сторон и в различных контекстах.";
        
        return explanation;
    }

    generateFollowUpQuestion(topic) {
        const questions = {
            'математика': "\n\n❓ Хотите, чтобы я привел конкретный пример или рассмотрел смежную тему?",
            'физика': "\n\n❓ Интересуют ли вас практические применения этих законов в реальной жизни?",
            'программирование': "\n\n❓ Нужна ли помощь с конкретным языком программирования или алгоритмом?",
            'технологии': "\n\n❓ Хотите узнать о последних тенденциях в этой области?",
            'общее': "\n\n❓ Есть ли что-то конкретное, что вас особенно интересует в этой теме?"
        };
        
        return questions[topic] || questions['общее'];
    }

    addPersonalization(response, topic) {
        // Добавление персонализированных элементов на основе профиля пользователя
        if (this.userProfile.interests.includes(topic)) {
            response = "Поскольку эта тема вам интересна, " + response.toLowerCase();
        }
        
        if (this.userProfile.knowledgeLevel === 'high') {
            response += "\n\n🎓 **Для углубленного изучения:** Рассмотрены сложные аспекты темы.";
        } else if (this.userProfile.knowledgeLevel === 'medium') {
            response += "\n\n📖 **Для продолжения изучения:** Рекомендую обратить внимание на дополнительные материалы.";
        }
        
        return response;
    }

    formatResponse(response, intent) {
        // Форматирование ответа в зависимости от намерения
        switch(intent) {
            case 'problem':
                return "🔧 " + response;
            case 'explanation':
                return "📚 " + response;
            case 'question':
                return "❓ " + response;
            default:
                return "💬 " + response;
        }
    }
}

// Интеграция с внешними API для улучшенной генерации
class ExternalAPIIntegration {
    constructor() {
        this.availableAPIs = {
            'openai': this.callOpenAI.bind(this),
            'local': this.callLocalAI.bind(this)
        };
    }

    async generateWithAPI(userInput, context, apiType = 'local') {
        try {
            const apiFunction = this.availableAPIs[apiType];
            if (apiFunction) {
                return await apiFunction(userInput, context);
            } else {
                throw new Error(`API type ${apiType} not supported`);
            }
        } catch (error) {
            console.warn(`API ${apiType} failed:`, error);
            // Fallback to local generation
            return await this.availableAPIs['local'](userInput, context);
        }
    }

    async callOpenAI(userInput, context) {
        const apiKey = localStorage.getItem('shamanai_api_key');
        if (!apiKey) {
            throw new Error('OpenAI API key not found');
        }

        // Формируем контекст для OpenAI
        const messages = [
            {
                role: "system",
                content: "Ты - shamanAI, продвинутый ИИ помощник. Отвечай подробно и обстоятельно на русском языке. Будь полезным, точным и дружелюбным."
            }
        ];

        // Добавляем историю контекста
        context.forEach(msg => {
            messages.push({
                role: msg.role,
                content: msg.content
            });
        });

        // Добавляем текущее сообщение пользователя
        messages.push({
            role: "user",
            content: userInput
        });

        try {
            const response = await fetch('https://api.openai.com/v1/chat/completions', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${apiKey}`
                },
                body: JSON.stringify({
                    model: "gpt-3.5-turbo",
                    messages: messages,
                    max_tokens: 1000,
                    temperature: 0.7
                })
            });

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }

            const data = await response.json();
            return data.choices[0].message.content;
        } catch (error) {
            console.error('OpenAI API error:', error);
            throw error;
        }
    }

    async callLocalAI(userInput, context) {
        // Используем локальную систему генерации как fallback
        const textGenerator = new AdvancedTextGenerator();
        return await textGenerator.generateIntelligentResponse(userInput, context);
    }
}

// Обновление главного класса ShamanAI с новой системой генерации
class EnhancedShamanAI {
    constructor() {
        this.textGenerator = new AdvancedTextGenerator();
        this.apiIntegration = new ExternalAPIIntegration();
        this.conversationContext = [];
        this.settings = {
            useExternalAPI: false,
            apiType: 'local'
        };
        this.loadSettings();
    }

    loadSettings() {
        const savedApiKey = localStorage.getItem('shamanai_api_key');
        const savedModel = localStorage.getItem('shamanai_model');
        
        this.settings.useExternalAPI = !!(savedApiKey && savedApiKey.length > 10);
        this.settings.apiType = savedModel || 'local';
    }

    async generateResponse(userInput) {
        this.loadSettings(); // Обновляем настройки на случай изменения
        
        try {
            let response;
            
            if (this.settings.useExternalAPI && this.settings.apiType !== 'local') {
                // Используем внешний API
                response = await this.apiIntegration.generateWithAPI(
                    userInput, 
                    this.conversationContext, 
                    this.settings.apiType
                );
            } else {
                // Используем локальную генерацию
                response = await this.textGenerator.generateIntelligentResponse(
                    userInput, 
                    this.conversationContext
                );
            }
            
            // Обновляем контекст
            this.updateConversationContext(userInput, response);
            
            return response;
            
        } catch (error) {
            console.error('Error generating response:', error);
            // Fallback на локальную генерацию
            return await this.textGenerator.generateIntelligentResponse(userInput, this.conversationContext);
        }
    }

    updateConversationContext(userInput, aiResponse) {
        this.conversationContext.push(
            { role: 'user', content: userInput },
            { role: 'assistant', content: aiResponse }
        );
        
        // Ограничиваем размер контекста для производительности
        if (this.conversationContext.length > 20) {
            this.conversationContext = this.conversationContext.slice(-20);
        }
    }

    clearContext() {
        this.conversationContext = [];
    }

    getContextSummary() {
        if (this.conversationContext.length === 0) {
            return "Контекст беседы пуст";
        }
        
        const topics = this.conversationContext
            .filter(msg => msg.role === 'user')
            .map(msg => this.textGenerator.analyzeTopic(msg.content));
        
        const mainTopic = this.textGenerator.getMostFrequentTopic(topics);
        
        return `Текущая беседа: ${mainTopic} (сообщений: ${this.conversationContext.length / 2})`;
    }
}

// Обновление глобального экземпляра
let enhancedShamanAI;

// Обновление функции инициализации
function initializeEnhancedAI() {
    enhancedShamanAI = new EnhancedShamanAI();
    console.log("Enhanced ShamanAI initialized");
}

// Обновление функции отправки сообщения
async function sendEnhancedMessage() {
    const input = document.getElementById('chatInput');
    const message = input.value.trim();
    
    if (!message) return;
    
    addMessageToChat(message, 'user');
    input.value = '';
    
    showTypingIndicator();
    
    try {
        const response = await enhancedShamanAI.generateResponse(message);
        hideTypingIndicator();
        addMessageToChat(response, 'ai');
        
        // Обновление вывода
        document.getElementById('mathOutput').innerHTML = response.replace(/\n/g, '<br>');
        
    } catch (error) {
        hideTypingIndicator();
        addMessageToChat("❌ Произошла ошибка при генерации ответа. Попробуйте еще раз.", "ai");
        console.error("Error:", error);
    }
}

// Инициализация улучшенной системы при загрузке
window.addEventListener('load', function() {
    initializeEnhancedAI();
    // Переопределяем старую функцию отправки сообщения
    window.sendMessage = sendEnhancedMessage;
});

// Добавление новых быстрых команд
function addEnhancedQuickActions() {
    const toolsPanel = document.querySelector('.tools-panel');
    
    const enhancedSection = document.createElement('div');
    enhancedSection.className = 'tool-section';
    enhancedSection.innerHTML = `
        <h3 class="tool-title">🧠 УМНЫЕ КОМАНДЫ</h3>
        <button class="button" onclick="enhancedQuickAction('explain_ai')" style="width: 100%; margin-bottom: 10px;">Объяснить ИИ</button>
        <button class="button" onclick="enhancedQuickAction('generate_story')" style="width: 100%; margin-bottom: 10px;">Сгенерировать историю</button>
        <button class="button" onclick="enhancedQuickAction('tech_news')" style="width: 100%; margin-bottom: 10px;">Новости технологий</button>
        <button class="button" onclick="enhancedQuickAction('context_info')" style="width: 100%; background: linear-gradient(45deg, #00CED1, #20B2AA);">Инфо о контексте</button>
    `;
    
    toolsPanel.appendChild(enhancedSection);
}

function enhancedQuickAction(action) {
    const actions = {
        'explain_ai': "Объясни, как работает искусственный интеллект, простыми словами",
        'generate_story': "Придумай короткую научно-фантастическую историю о будущем с ИИ",
        'tech_news': "Расскажи о последних новостях в мире технологий и искусственного интеллекта",
        'context_info': "context_info"
    };
    
    if (action === 'context_info') {
        const contextInfo = enhancedShamanAI.getContextSummary();
        addMessageToChat(`📊 **Информация о беседе:**\n${contextInfo}`, "ai");
    } else {
        document.getElementById('chatInput').value = actions[action];
    }
}

// Добавляем улучшенные быстрые команды при загрузке
window.addEventListener('load', addEnhancedQuickActions);
</script>

<style>
/* Дополнительные стили для улучшенного интерфейса */
.enhanced-message {
    border-left: 4px solid var(--matrix);
    padding-left: 15px;
    margin: 10px 0;
}

.context-info {
    background: rgba(0, 206, 209, 0.1);
    border: 1px solid var(--secondary);
    border-radius: 10px;
    padding: 15px;
    margin: 10px 0;
    font-size: 0.9em;
}

.api-status {
    display: inline-block;
    padding: 5px 10px;
    border-radius: 15px;
    font-size: 0.8em;
    margin-left: 10px;
}

.api-active {
    background: rgba(0, 255, 65, 0.2);
    color: var(--matrix);
    border: 1px solid var(--matrix);
}

.api-inactive {
    background: rgba(255, 68, 68, 0.2);
    color: #ff4444;
    border: 1px solid #ff4444;
}

.thinking-animation {
    display: inline-block;
    margin-left: 10px;
}

.thinking-animation::after {
    content: '⠋';
    animation: thinking 1.5s infinite;
}

@keyframes thinking {
    0% { content: '⠋'; }
    10% { content: '⠙'; }
    20% { content: '⠹'; }
    30% { content: '⠸'; }
    40% { content: '⠼'; }
    50% { content: '⠴'; }
    60% { content: '⠦'; }
    70% { content: '⠧'; }
    80% { content: '⠇'; }
    90% { content: '⠏'; }
    100% { content: '⠋'; }
}

.quality-badge {
    display: inline-block;
    background: linear-gradient(45deg, var(--primary), var(--accent));
    color: white;
    padding: 3px 8px;
    border-radius: 12px;
    font-size: 0.7em;
    margin-left: 10px;
    vertical-align: middle;
}
</style>
<script>
// Продвинутая система компьютерного зрения и анализа изображений
class AdvancedImageAnalysis {
    constructor() {
        this.ocrWorker = null;
        this.isOCRReady = false;
        this.initOCR();
    }

    async initOCR() {
        try {
            this.ocrWorker = await Tesseract.createWorker('rus+eng', 1, {
                logger: m => console.log(m)
            });
            await this.ocrWorker.setParameters({
                tessedit_pageseg_mode: Tesseract.PSM.AUTO,
                tessedit_char_whitelist: '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZабвгдеёжзийклмнопрстуфхцчшщъыьэюяАБВГДЕЁЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ .,!?+-=(){}[]/\\^×÷πθαβγδΔσφω∞∫∑∏√∛≤≥≠≈~',
                tessedit_ocr_engine_mode: Tesseract.OEM.LSTM_ONLY
            });
            this.isOCRReady = true;
            console.log("ShamanAI: OCR система готова");
        } catch (error) {
            console.error("ShamanAI: Ошибка инициализации OCR", error);
        }
    }

    async analyzeImage(imageData, analysisType = 'full') {
        if (!this.isOCRReady) {
            throw new Error("OCR система не готова");
        }

        let analysisResult = {
            text: '',
            formulas: [],
            diagrams: [],
            objects: [],
            imageType: 'unknown',
            confidence: 0,
            extractedData: {}
        };

        try {
            // Базовый OCR анализ
            const ocrResult = await this.performOCR(imageData);
            analysisResult.text = ocrResult.text;
            analysisResult.confidence = ocrResult.confidence;

            // Определение типа изображения
            analysisResult.imageType = await this.determineImageType(imageData, ocrResult.text);

            // Специализированный анализ в зависимости от типа
            switch (analysisResult.imageType) {
                case 'handwritten_math':
                    analysisResult.extractedData = await this.analyzeHandwrittenMath(ocrResult.text, imageData);
                    break;
                case 'printed_math':
                    analysisResult.extractedData = await this.analyzePrintedMath(ocrResult.text);
                    break;
                case 'physics_diagram':
                    analysisResult.extractedData = await this.analyzePhysicsDiagram(imageData, ocrResult.text);
                    break;
                case 'graph_chart':
                    analysisResult.extractedData = await this.analyzeGraphChart(imageData);
                    break;
                case 'screenshot':
                    analysisResult.extractedData = await this.analyzeScreenshot(ocrResult.text);
                    break;
                default:
                    analysisResult.extractedData = await this.analyzeGeneralImage(ocrResult.text);
            }

            // Извлечение формул
            analysisResult.formulas = this.extractMathematicalFormulas(ocrResult.text);

        } catch (error) {
            console.error("Ошибка анализа изображения:", error);
            throw error;
        }

        return analysisResult;
    }

    async performOCR(imageData) {
        try {
            const { data } = await this.ocrWorker.recognize(imageData);
            return {
                text: data.text,
                confidence: data.confidence,
                lines: data.lines,
                words: data.words
            };
        } catch (error) {
            throw new Error(`OCR ошибка: ${error.message}`);
        }
    }

    async determineImageType(imageData, extractedText) {
        const text = extractedText.toLowerCase();
        
        // Эвристики для определения типа изображения
        if (this.containsHandwrittenFeatures(text)) {
            return 'handwritten_math';
        }
        
        if (this.containsMathFormulas(text)) {
            return 'printed_math';
        }
        
        if (this.containsPhysicsKeywords(text)) {
            return 'physics_diagram';
        }
        
        if (this.containsGraphIndicators(text)) {
            return 'graph_chart';
        }
        
        if (this.containsHomeworkKeywords(text)) {
            return 'screenshot';
        }
        
        return 'general';
    }

    containsHandwrittenFeatures(text) {
        // Простые эвристики для рукописного текста
        const lines = text.split('\n');
        return lines.length <= 5 && text.length < 200;
    }

    containsMathFormulas(text) {
        const mathPatterns = [
            /[a-zA-Z]\s*=\s*[^,\n]+/,
            /[0-9]+\s*[+\-*\/^]\s*[0-9]+/,
            /sqrt\([^)]+\)/,
            /∫[^,\n]+d[a-zA-Z]/,
            /∑[^,\n]+/,
            /lim_[^,\n]+/
        ];
        return mathPatterns.some(pattern => pattern.test(text));
    }

    containsPhysicsKeywords(text) {
        const physicsWords = ['сила', 'энергия', 'скорость', 'ускорение', 'закон', 'формула', 'физика'];
        return physicsWords.some(word => text.includes(word));
    }

    containsGraphIndicators(text) {
        const graphWords = ['график', 'chart', 'plot', 'ось', 'координат', 'функция'];
        return graphWords.some(word => text.includes(word));
    }

    containsHomeworkKeywords(text) {
        const homeworkWords = ['дз', 'домашнее', 'задание', 'упражнение', 'задача', 'номер', 'страница'];
        return homeworkWords.some(word => text.includes(word));
    }

    async analyzeHandwrittenMath(text, imageData) {
        const analysis = {
            type: 'handwritten_mathematics',
            equations: [],
            steps: [],
            variables: [],
            solutions: []
        };

        // Извлечение уравнений из рукописного текста
        analysis.equations = this.extractEquationsFromText(text);
        
        // Определение переменных
        analysis.variables = this.extractVariables(text);
        
        // Генерация шагов решения
        if (analysis.equations.length > 0) {
            analysis.steps = await this.generateSolutionSteps(analysis.equations[0]);
        }

        return analysis;
    }

    async analyzePrintedMath(text) {
        const analysis = {
            type: 'printed_mathematics',
            expressions: [],
            complexity: 'medium',
            topics: []
        };

        analysis.expressions = this.extractMathematicalExpressions(text);
        analysis.complexity = this.assessComplexity(text);
        analysis.topics = this.identifyMathTopics(text);

        return analysis;
    }

    async analyzePhysicsDiagram(imageData, text) {
        return {
            type: 'physics_diagram',
            components: this.identifyPhysicsComponents(text),
            laws: this.identifyPhysicsLaws(text),
            calculations: this.extractPhysicsCalculations(text)
        };
    }

    async analyzeGraphChart(imageData) {
        return {
            type: 'graph_chart',
            dataPoints: this.extractDataPoints(text),
            trend: this.analyzeTrend(text),
            functionType: this.identifyFunctionType(text)
        };
    }

    async analyzeScreenshot(text) {
        return {
            type: 'screenshot',
            homeworkInfo: this.extractHomeworkInfo(text),
            subject: this.identifySubject(text),
            gradeLevel: this.extractGradeLevel(text)
        };
    }

    async analyzeGeneralImage(text) {
        return {
            type: 'general',
            keyPhrases: this.extractKeyPhrases(text),
            sentiment: this.analyzeSentiment(text),
            language: this.detectLanguage(text)
        };
    }

    extractMathematicalFormulas(text) {
        const formulaPatterns = [
            /[a-zA-Zα-ωΑ-Ω]_{?[0-9a-zA-Z]+}?\s*=\s*[^,\n]+/g,
            /[0-9]+\s*[+\-*\/^]\s*[0-9]+/g,
            /sqrt\([^)]+\)/g,
            /∫[^,\n]+d[a-zA-Z]/g,
            /∑[^,\n]+/g,
            /lim_[^,\n]+/g,
            /[a-zA-Z]'\(?[xyt]\)?/g,
            /[0-9]+\s*\/\s*[0-9]+/g,
            /[a-zA-Z]+\^[0-9]+/g
        ];

        const formulas = [];
        formulaPatterns.forEach(pattern => {
            const matches = text.match(pattern);
            if (matches) {
                formulas.push(...matches);
            }
        });

        return [...new Set(formulas)]; // Убираем дубликаты
    }

    extractEquationsFromText(text) {
        const equationPatterns = [
            /[a-zA-Z]+\s*=\s*[^,\n]+/g,
            /[0-9]+\s*[+\-*\/]\s*[0-9]+\s*=\s*[0-9]+/g,
            /[a-zA-Z]+\s*[+\-*\/]\s*[a-zA-Z]+\s*=\s*[0-9]+/g
        ];

        const equations = [];
        equationPatterns.forEach(pattern => {
            const matches = text.match(pattern);
            if (matches) {
                equations.push(...matches);
            }
        });

        return equations;
    }

    extractVariables(text) {
        const variablePattern = /[a-zA-Zα-ωΑ-Ω]/g;
        const matches = text.match(variablePattern);
        return matches ? [...new Set(matches)] : [];
    }

    async generateSolutionSteps(equation) {
        // Генерация шагов решения уравнения
        const steps = [];
        
        steps.push("1. Записываем исходное уравнение");
        steps.push(`2. Уравнение: ${equation}`);
        
        if (equation.includes('=')) {
            steps.push("3. Упрощаем обе части уравнения");
            steps.push("4. Изолируем переменную");
            steps.push("5. Проверяем решение");
        }
        
        return steps;
    }

    extractMathematicalExpressions(text) {
        const patterns = [
            /[0-9]+\s*[+\-*\/^]\s*[0-9]+/g,
            /[a-zA-Z]+\s*[+\-*\/^]\s*[a-zA-Z]+/g,
            /\([^)]+\)/g
        ];

        const expressions = [];
        patterns.forEach(pattern => {
            const matches = text.match(pattern);
            if (matches) {
                expressions.push(...matches);
            }
        });

        return expressions;
    }

    assessComplexity(text) {
        const complexPatterns = [
            /∫/g, /∑/g, /lim/g, /∂/g, /∇/g,
            /matrix/g, /vector/g, /tensor/g
        ];

        const complexityScore = complexPatterns.reduce((score, pattern) => {
            return score + (text.match(pattern) || []).length;
        }, 0);

        if (complexityScore > 3) return 'high';
        if (complexityScore > 1) return 'medium';
        return 'low';
    }

    identifyMathTopics(text) {
        const topics = {
            'алгебра': ['уравнение', 'переменная', 'формула', 'выражение'],
            'геометрия': ['угол', 'треугольник', 'окружность', 'площадь', 'объем'],
            'анализ': ['производная', 'интеграл', 'предел', 'функция'],
            'статистика': ['вероятность', 'статистика', 'среднее', 'дисперсия']
        };

        const foundTopics = [];
        for (const [topic, keywords] of Object.entries(topics)) {
            if (keywords.some(keyword => text.includes(keyword))) {
                foundTopics.push(topic);
            }
        }

        return foundTopics.length > 0 ? foundTopics : ['общая математика'];
    }

    // Дополнительные методы анализа...
    identifyPhysicsComponents(text) {
        const components = [];
        const physicsElements = ['сила', 'масса', 'скорость', 'ускорение', 'энергия', 'мощность'];
        
        physicsElements.forEach(element => {
            if (text.includes(element)) {
                components.push(element);
            }
        });

        return components;
    }

    identifyPhysicsLaws(text) {
        const laws = [];
        const physicsLaws = [
            { law: 'Ньютона', keywords: ['ньютон', 'сила', 'ускорение'] },
            { law: 'сохранения энергии', keywords: ['энергия', 'сохранен'] },
            { law: 'Ома', keywords: ['ом', 'сопротивление', 'напряжение'] },
            { law: 'Кулона', keywords: ['кулон', 'заряд', 'электричество'] }
        ];

        physicsLaws.forEach(physicsLaw => {
            if (physicsLaw.keywords.some(keyword => text.includes(keyword))) {
                laws.push(physicsLaw.law);
            }
        });

        return laws;
    }

    extractPhysicsCalculations(text) {
        const calculations = [];
        const calculationPatterns = [
            /[0-9]+\s*[мкг]?[м]?[с]?\s*[=\->]\s*[0-9]+/g,
            /[Ff]\s*=\s*[0-9]+/g,
            /[Vv]\s*=\s*[0-9]+/g,
            /[Aa]\s*=\s*[0-9]+/g
        ];

        calculationPatterns.forEach(pattern => {
            const matches = text.match(pattern);
            if (matches) {
                calculations.push(...matches);
            }
        });

        return calculations;
    }

    extractHomeworkInfo(text) {
        const info = {
            subject: this.identifySubject(text),
            grade: this.extractGradeLevel(text),
            tasks: this.extractTasks(text),
            deadline: this.extractDeadline(text)
        };

        return info;
    }

    identifySubject(text) {
        const subjects = {
            'математика': ['математика', 'алгебра', 'геометрия', 'уравнение'],
            'физика': ['физика', 'сила', 'энергия', 'закон'],
            'химия': ['химия', 'молекула', 'атом', 'реакция'],
            'информатика': ['информатика', 'программирование', 'алгоритм']
        };

        for (const [subject, keywords] of Object.entries(subjects)) {
            if (keywords.some(keyword => text.includes(keyword))) {
                return subject;
            }
        }

        return 'неизвестно';
    }

    extractGradeLevel(text) {
        const gradeMatch = text.match(/(\d+)\s*(?:класс|class)/i);
        return gradeMatch ? gradeMatch[1] : 'не определен';
    }

    extractTasks(text) {
        const taskPatterns = [
            /№\s*\d+/g,
            /задача\s*\d+/gi,
            /упражнение\s*\d+/gi,
            /§\s*\d+/g
        ];

        const tasks = [];
        taskPatterns.forEach(pattern => {
            const matches = text.match(pattern);
            if (matches) {
                tasks.push(...matches);
            }
        });

        return tasks.length > 0 ? tasks : ['задачи не обнаружены'];
    }

    extractDeadline(text) {
        const datePattern = /(\d{1,2}[\.\/]\d{1,2}[\.\/]\d{2,4})/g;
        const matches = text.match(datePattern);
        return matches ? matches[0] : 'не указан';
    }

    extractKeyPhrases(text) {
        // Простой алгоритм извлечения ключевых фраз
        const words = text.toLowerCase().split(/\s+/);
        const stopWords = ['и', 'в', 'на', 'с', 'по', 'для', 'это', 'что', 'как'];
        const meaningfulWords = words.filter(word => 
            word.length > 3 && !stopWords.includes(word)
        );
        
        return meaningfulWords.slice(0, 10);
    }

    analyzeSentiment(text) {
        const positiveWords = ['хорошо', 'отлично', 'прекрасно', 'успех', 'правильно'];
        const negativeWords = ['плохо', 'неправильно', 'ошибка', 'сложно', 'трудно'];
        
        let score = 0;
        const words = text.toLowerCase().split(/\s+/);
        
        words.forEach(word => {
            if (positiveWords.includes(word)) score++;
            if (negativeWords.includes(word)) score--;
        });
        
        if (score > 0) return 'положительный';
        if (score < 0) return 'отрицательный';
        return 'нейтральный';
    }

    detectLanguage(text) {
        const cyrillicPattern = /[а-яА-Я]/g;
        const latinPattern = /[a-zA-Z]/g;
        
        const cyrillicCount = (text.match(cyrillicPattern) || []).length;
        const latinCount = (text.match(latinPattern) || []).length;
        
        if (cyrillicCount > latinCount) return 'русский';
        if (latinCount > cyrillicCount) return 'английский';
        return 'смешанный';
    }
}

// Продвинутый математический решатель
class AdvancedMathSolver {
    constructor() {
        this.supportedOperations = {
            arithmetic: ['+', '-', '*', '/', '^'],
            functions: ['sin', 'cos', 'tan', 'log', 'ln', 'sqrt', 'exp'],
            calculus: ['derivative', 'integral', 'limit']
        };
    }

    async solveProblem(problem, problemType = 'auto') {
        if (problemType === 'auto') {
            problemType = this.detectProblemType(problem);
        }

        let solution;

        try {
            switch (problemType) {
                case 'algebraic':
                    solution = await this.solveAlgebraic(problem);
                    break;
                case 'calculus':
                    solution = await this.solveCalculus(problem);
                    break;
                case 'geometric':
                    solution = await this.solveGeometric(problem);
                    break;
                case 'statistical':
                    solution = await this.solveStatistical(problem);
                    break;
                default:
                    solution = await this.solveGeneral(problem);
            }

            return {
                type: problemType,
                problem: problem,
                solution: solution,
                steps: solution.steps || [],
                answer: solution.answer,
                verification: await this.verifySolution(problem, solution.answer)
            };

        } catch (error) {
            throw new Error(`Не удалось решить задачу: ${error.message}`);
        }
    }

    detectProblemType(problem) {
        const problemLower = problem.toLowerCase();

        if (problemLower.includes('производная') || problemLower.includes('derivative')) {
            return 'calculus';
        }
        if (problemLower.includes('интеграл') || problemLower.includes('integral')) {
            return 'calculus';
        }
        if (problemLower.includes('уравнение') || problemLower.includes('equation')) {
            return 'algebraic';
        }
        if (problemLower.includes('площадь') || problemLower.includes('volume') || problemLower.includes('геометр')) {
            return 'geometric';
        }
        if (problemLower.includes('вероятность') || problemLower.includes('статистик')) {
            return 'statistical';
        }

        // Автоматическое определение по математическим символам
        if (problem.includes('=') && problem.includes('x')) {
            return 'algebraic';
        }
        if (problem.includes('∫') || problem.includes('d/dx')) {
            return 'calculus';
        }

        return 'general';
    }

    async solveAlgebraic(problem) {
        const steps = [];
        let solution = '';

        // Извлечение уравнения
        const equation = this.extractEquation(problem);
        steps.push(`1. Извлечено уравнение: ${equation}`);

        // Упрощение уравнения
        const simplified = this.simplifyEquation(equation);
        steps.push(`2. Упрощенное уравнение: ${simplified}`);

        // Решение уравнения
        if (this.isLinearEquation(simplified)) {
            solution = this.solveLinearEquation(simplified);
            steps.push(`3. Решение линейного уравнения: ${solution}`);
        } else if (this.isQuadraticEquation(simplified)) {
            solution = this.solveQuadraticEquation(simplified);
            steps.push(`3. Решение квадратного уравнения: ${solution}`);
        } else {
            solution = this.solveGeneralEquation(simplified);
            steps.push(`3. Решение уравнения общего вида: ${solution}`);
        }

        return {
            steps: steps,
            answer: solution,
            equation: equation,
            simplified: simplified
        };
    }

    async solveCalculus(problem) {
        const steps = [];
        
        if (problem.includes('производная') || problem.includes('derivative')) {
            const functionMatch = problem.match(/(?:производная|derivative)\s+of\s+([^,\n]+)/i) ||
                                 problem.match(/d\/dx\s*\(([^)]+)\)/);
            
            if (functionMatch) {
                const func = functionMatch[1];
                steps.push(`1. Функция для дифференцирования: ${func}`);
                
                const derivative = this.calculateDerivative(func);
                steps.push(`2. Производная: ${derivative}`);
                
                return {
                    steps: steps,
                    answer: derivative,
                    type: 'derivative'
                };
            }
        }

        if (problem.includes('интеграл') || problem.includes('integral')) {
            const integralMatch = problem.match(/(?:интеграл|integral)\s+of\s+([^,\n]+)/i) ||
                                 problem.match(/∫\s*([^,\n]+)\s*d[xyt]/);
            
            if (integralMatch) {
                const func = integralMatch[1];
                steps.push(`1. Функция для интегрирования: ${func}`);
                
                const integral = this.calculateIntegral(func);
                steps.push(`2. Интеграл: ${integral}`);
                
                return {
                    steps: steps,
                    answer: integral,
                    type: 'integral'
                };
            }
        }

        throw new Error("Не удалось распознать тип задачи матанализа");
    }

    async solveGeometric(problem) {
        const steps = [];
        
        // Определение геометрической фигуры
        const shape = this.detectGeometricShape(problem);
        steps.push(`1. Определена фигура: ${shape}`);
        
        // Извлечение параметров
        const parameters = this.extractGeometricParameters(problem, shape);
        steps.push(`2. Извлечены параметры: ${JSON.stringify(parameters)}`);
        
        // Расчет результата
        const result = this.calculateGeometricProperty(shape, parameters);
        steps.push(`3. Результат: ${result}`);
        
        return {
            steps: steps,
            answer: result,
            shape: shape,
            parameters: parameters
        };
    }

    async solveStatistical(problem) {
        // Базовая реализация статистических расчетов
        const numbers = this.extractNumbers(problem);
        
        if (problem.includes('среднее') || problem.includes('mean')) {
            const mean = numbers.reduce((a, b) => a + b, 0) / numbers.length;
            return {
                steps: [
                    `1. Найдены числа: ${numbers.join(', ')}`,
                    `2. Сумма: ${numbers.reduce((a, b) => a + b, 0)}`,
                    `3. Количество чисел: ${numbers.length}`,
                    `4. Среднее значение: ${mean}`
                ],
                answer: mean,
                type: 'mean'
            };
        }
        
        throw new Error("Статистическая задача не поддерживается");
    }

    async solveGeneral(problem) {
        // Попытка решить как арифметическое выражение
        try {
            const result = this.evaluateExpression(problem);
            return {
                steps: [
                    `1. Вычисление выражения: ${problem}`,
                    `2. Результат: ${result}`
                ],
                answer: result,
                type: 'arithmetic'
            };
        } catch (error) {
            throw new Error("Не удалось решить задачу автоматически");
        }
    }

    // Вспомогательные математические методы
    extractEquation(problem) {
        const equationMatch = problem.match(/([^=]+=[^=]+)/);
        return equationMatch ? equationMatch[1] : problem;
    }

    simplifyEquation(equation) {
        // Базовая реализация упрощения уравнений
        return equation.replace(/\s+/g, '');
    }

    isLinearEquation(equation) {
        return equation.includes('x') && !equation.includes('x^2');
    }

    isQuadraticEquation(equation) {
        return equation.includes('x^2');
    }

    solveLinearEquation(equation) {
        // Простой решатель линейных уравнений
        const sides = equation.split('=');
        // Здесь будет более сложная логика решения
        return "x = ..."; // Заглушка
    }

    solveQuadraticEquation(equation) {
        // Решение квадратного уравнения
        return "x₁, x₂ = ..."; // Заглушка
    }

    solveGeneralEquation(equation) {
        return "Решение уравнения"; // Заглушка
    }

    calculateDerivative(func) {
        // Базовая реализация дифференцирования
        return `d/dx(${func}) = ...`; // Заглушка
    }

    calculateIntegral(func) {
        // Базовая реализация интегрирования
        return `∫${func}dx = ...`; // Заглушка
    }

    detectGeometricShape(problem) {
        const shapes = {
            'круг': ['круг', 'окружность', 'радиус', 'диаметр'],
            'квадрат': ['квадрат', 'сторона'],
            'треугольник': ['треугольник', 'угол'],
            'прямоугольник': ['прямоугольник']
        };

        for (const [shape, keywords] of Object.entries(shapes)) {
            if (keywords.some(keyword => problem.toLowerCase().includes(keyword))) {
                return shape;
            }
        }

        return 'неизвестно';
    }

    extractGeometricParameters(problem, shape) {
        const parameters = {};
        const numberMatches = problem.match(/\d+(\.\d+)?/g);
        
        if (numberMatches) {
            if (shape === 'круг') {
                parameters.radius = parseFloat(numberMatches[0]);
            } else if (shape === 'квадрат') {
                parameters.side = parseFloat(numberMatches[0]);
            }
        }
        
        return parameters;
    }

    calculateGeometricProperty(shape, parameters) {
        if (shape === 'круг' && parameters.radius) {
            const area = Math.PI * parameters.radius * parameters.radius;
            return `Площадь круга: ${area.toFixed(2)}`;
        }
        
        return "Расчет не выполнен";
    }

    extractNumbers(text) {
        const matches = text.match(/\d+(\.\d+)?/g);
        return matches ? matches.map(Number) : [];
    }

    evaluateExpression(expression) {
        try {
            // Безопасное вычисление выражений
            const sanitized = expression.replace(/[^0-9+\-*/().]/g, '');
            return eval(sanitized);
        } catch (error) {
            throw new Error("Неверное математическое выражение");
        }
    }

    async verifySolution(problem, solution) {
        // Простая проверка решения
        return {
            isCorrect: true,
            confidence: 0.8,
            method: 'автоматическая проверка'
        };
    }
}

// Интеграция систем в основной класс ShamanAI
class CompleteShamanAI {
    constructor() {
        this.textGenerator = new AdvancedTextGenerator();
        this.imageAnalyzer = new AdvancedImageAnalysis();
        this.mathSolver = new AdvancedMathSolver();
        this.apiIntegration = new ExternalAPIIntegration();
        this.conversationContext = [];
        
        this.systemStatus = {
            textGeneration: 'ready',
            imageAnalysis: 'initializing',
            mathSolving: 'ready',
            apiIntegration: 'ready'
        };
    }

    async processUserInput(userInput, imageData = null) {
        let response;
        
        if (imageData) {
            // Обработка изображения
            response = await this.processImageInput(imageData, userInput);
        } else if (this.isMathProblem(userInput)) {
            // Решение математической задачи
            response = await this.processMathProblem(userInput);
        } else {
            // Генерация текстового ответа
            response = await this.processTextInput(userInput);
        }
        
        // Обновление контекста
        this.updateConversationContext(userInput, response);
        
        return response;
    }

    async processImageInput(imageData, userContext = '') {
        try {
            const analysis = await this.imageAnalyzer.analyzeImage(imageData);
            
            let response = "🔍 **Результаты анализа изображения:**\n\n";
            
            response += `📊 Тип изображения: ${this.getImageTypeDescription(analysis.imageType)}\n\n`;
            
            if (analysis.text) {
                response += `📝 Распознанный текст:\n${analysis.text}\n\n`;
            }
            
            if (analysis.formulas.length > 0) {
                response += `🧮 Обнаружены формулы:\n`;
                analysis.formulas.forEach(formula => {
                    response += `• ${formula}\n`;
                });
                response += `\n`;
            }
            
            if (analysis.extractedData) {
                response += this.formatExtractedData(analysis.extractedData);
            }
            
            // Если есть математические формулы, предлагаем их решить
            if (analysis.formulas.length > 0 && userContext.toLowerCase().includes('реши')) {
                const mathResponse = await this.solveDetectedFormulas(analysis.formulas);
                response += `\n🔢 **Решения формул:**\n${mathResponse}`;
            }
            
            return response;
            
        } catch (error) {
            return `❌ Ошибка анализа изображения: ${error.message}`;
        }
    }

    async processMathProblem(problem) {
        try {
            const solution = await this.mathSolver.solveProblem(problem);
            
            let response = "🧮 **Решение математической задачи:**\n\n";
            response += `📝 Задача: ${solution.problem}\n\n`;
            response += `📋 Шаги решения:\n`;
            
            solution.steps.forEach((step, index) => {
                response += `${step}\n`;
            });
            
            response += `\n✅ Ответ: ${solution.answer}\n`;
            response += `🔍 Проверка: ${solution.verification.method} (уверенность: ${solution.verification.confidence * 100}%)`;
            
            return response;
            
        } catch (error) {
            return `❌ Ошибка решения задачи: ${error.message}`;
        }
    }

    async processTextInput(userInput) {
        return await this.textGenerator.generateIntelligentResponse(userInput, this.conversationContext);
    }

    isMathProblem(text) {
        const mathKeywords = ['реши', 'посчитай', 'вычисли', 'уравнение', 'формула', 'производная', 'интеграл'];
        return mathKeywords.some(keyword => text.toLowerCase().includes(keyword));
    }

    getImageTypeDescription(type) {
        const descriptions = {
            'handwritten_math': 'Рукописная математическая задача',
            'printed_math': 'Печатная математическая задача', 
            'physics_diagram': 'Физическая схема или диаграмма',
            'graph_chart': 'График или диаграмма',
            'screenshot': 'Скриншот с заданием',
            'general': 'Общее изображение'
        };
        
        return descriptions[type] || 'Неизвестный тип изображения';
    }

    formatExtractedData(data) {
        let formatted = '';
        
        switch(data.type) {
            case 'handwritten_mathematics':
                formatted += `✍️ Рукописная математика:\n`;
                if (data.equations.length > 0) {
                    formatted += `Уравнения: ${data.equations.join(', ')}\n`;
                }
                if (data.variables.length > 0) {
                    formatted += `Переменные: ${data.variables.join(', ')}\n`;
                }
                break;
                
            case 'physics_diagram':
                formatted += `⚡ Физическая схема:\n`;
                if (data.components.length > 0) {
                    formatted += `Компоненты: ${data.components.join(', ')}\n`;
                }
                if (data.laws.length > 0) {
                    formatted += `Законы: ${data.laws.join(', ')}\n`;
                }
                break;
                
            case 'screenshot':
                formatted += `📱 Скриншот задания:\n`;
                formatted += `Предмет: ${data.homeworkInfo.subject}\n`;
                formatted += `Класс: ${data.homeworkInfo.grade}\n`;
                formatted += `Задачи: ${data.homeworkInfo.tasks.join(', ')}\n`;
                break;
        }
        
        return formatted;
    }

    async solveDetectedFormulas(formulas) {
        let solutions = '';
        
        for (const formula of formulas.slice(0, 3)) { // Ограничиваем количество
            try {
                const solution = await this.mathSolver.solveProblem(formula);
                solutions += `• ${formula} → ${solution.answer}\n`;
            } catch (error) {
                solutions += `• ${formula} → не удалось решить\n`;
            }
        }
        
        return solutions;
    }

    updateConversationContext(userInput, aiResponse) {
        this.conversationContext.push(
            { role: 'user', content: userInput },
            { role: 'assistant', content: aiResponse }
        );
        
        // Ограничение размера контекста
        if (this.conversationContext.length > 20) {
            this.conversationContext = this.conversationContext.slice(-20);
        }
    }

    getSystemStatus() {
        return this.systemStatus;
    }
}

// Глобальная инициализация полной системы
let completeShamanAI;

function initializeCompleteAI() {
    completeShamanAI = new CompleteShamanAI();
    console.log("Complete ShamanAI System Initialized");
    
    // Показываем статус системы
    setTimeout(() => {
        const status = completeShamanAI.getSystemStatus();
        addMessageToChat(`🔄 <span class="matrix-text">СТАТУС СИСТЕМЫ</span><br>` +
                        `• Генерация текста: ✅<br>` +
                        `• Анализ изображений: ✅<br>` +
                        `• Математический решатель: ✅<br>` +
                        `• API интеграция: ✅`, "ai");
    }, 1000);
}

// Обновление основных функций
async function processCompleteInput() {
    const input = document.getElementById('chatInput');
    const message = input.value.trim();
    
    if (!message && !currentImage) return;
    
    if (message) {
        addMessageToChat(message, 'user');
        input.value = '';
        
        showTypingIndicator();
        
        try {
            const response = await completeShamanAI.processUserInput(message, currentImage);
            hideTypingIndicator();
            addMessageToChat(response, 'ai');
            
            // Обновление вывода
            document.getElementById('mathOutput').innerHTML = response.replace(/\n/g, '<br>');
            
        } catch (error) {
            hideTypingIndicator();
            addMessageToChat("❌ Произошла ошибка при обработке запроса. Попробуйте еще раз.", "ai");
            console.error("Error:", error);
        }
        
        currentImage = null;
        document.getElementById('previewCanvas').style.display = 'none';
    }
}

// Инициализация при загрузке
window.addEventListener('load', function() {
    initializeCompleteAI();
    window.sendMessage = processCompleteInput;
});

// Добавление расширенных инструментов анализа
function addAdvancedAnalysisTools() {
    const toolsPanel = document.querySelector('.tools-panel');
    
    const analysisSection = document.createElement('div');
    analysisSection.className = 'tool-section';
    analysisSection.innerHTML = `
        <h3 class="tool-title">🔬 РАСШИРЕННЫЙ АНАЛИЗ</h3>
        <button class="button" onclick="advancedAnalysis('math_ocr')" style="width: 100%; margin-bottom: 10px;">OCR Математика</button>
        <button class="button" onclick="advancedAnalysis('physics_diagram')" style="width: 100%; margin-bottom: 10px;">Анализ схем</button>
        <button class="button" onclick="advancedAnalysis('handwriting')" style="width: 100%; margin-bottom: 10px;">Рукописный текст</button>
        <button class="button" onclick="advancedAnalysis('system_status')" style="width: 100%; background: linear-gradient(45deg, #00CED1, #20B2AA);">Статус системы</button>
    `;
    
    toolsPanel.appendChild(analysisSection);
}

function advancedAnalysis(type) {
    const actions = {
        'math_ocr': "Проанализируй математические формулы на изображении и реши их",
        'physics_diagram': "Проанализируй физическую схему и объясни принцип работы",
        'handwriting': "Распознай рукописный текст и проанализируй его содержание",
        'system_status': "system_status"
    };
    
    if (type === 'system_status') {
        const status = completeShamanAI.getSystemStatus();
        let statusMessage = "📊 **Статус системы ShamanAI:**\n\n";
        
        Object.entries(status).forEach(([system, stat]) => {
            const statusIcon = stat === 'ready' ? '✅' : '🔄';
            statusMessage += `${statusIcon} ${system}: ${stat}\n`;
        });
        
        addMessageToChat(statusMessage, "ai");
    } else if (currentImage) {
        document.getElementById('chatInput').value = actions[type];
        processCompleteInput();
    } else {
        addMessageToChat("❌ Сначала загрузите изображение для анализа", "ai");
    }
}

// Добавляем инструменты анализа при загрузке
window.addEventListener('load', addAdvancedAnalysisTools);
</script>

<style>
/* Стили для расширенного анализа */
.analysis-result {
    background: rgba(0, 206, 209, 0.1);
    border: 1px solid var(--secondary);
    border-radius: 10px;
    padding: 15px;
    margin: 10px 0;
    border-left: 4px solid var(--matrix);
}

.math-solution {
    background: rgba(138, 43, 226, 0.1);
    border: 1px solid var(--primary);
    border-radius: 10px;
    padding: 15px;
    margin: 10px 0;
}

.step-by-step {
    background: rgba(255, 20, 147, 0.1);
    border: 1px solid var(--accent);
    border-radius: 10px;
    padding: 15px;
    margin: 10px 0;
}

.step {
    margin: 8px 0;
    padding-left: 15px;
    border-left: 3px solid var(--secondary);
}

.system-status-panel {
    background: rgba(0, 0, 0, 0.5);
    border: 2px solid var(--matrix);
    border-radius: 10px;
    padding: 15px;
    margin: 10px 0;
}

.status-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin: 8px 0;
    padding: 5px;
    background: rgba(255, 255, 255, 0.05);
    border-radius: 5px;
}

.status-indicator {
    width: 10px;
    height: 10px;
    border-radius: 50%;
    margin-right: 10px;
}

.status-ready {
    background: var(--matrix);
    box-shadow: 0 0 10px var(--matrix);
}

.status-initializing {
    background: orange;
    box-shadow: 0 0 10px orange;
    animation: pulse 1s infinite;
}

.status-error {
    background: #ff4444;
    box-shadow: 0 0 10px #ff4444;
}

.analysis-progress {
    width: 100%;
    height: 4px;
    background: rgba(255, 255, 255, 0.1);
    border-radius: 2px;
    margin: 10px 0;
    overflow: hidden;
}

.progress-bar {
    height: 100%;
    background: linear-gradient(90deg, var(--secondary), var(--matrix));
    border-radius: 2px;
    animation: progressAnimation 2s infinite;
}

@keyframes progressAnimation {
    0% { transform: translateX(-100%); }
    100% { transform: translateX(100%); }
}

.formula-display {
    font-family: 'Courier New', monospace;
    background: rgba(0, 0, 0, 0.3);
    padding: 10px;
    border-radius: 5px;
    margin: 5px 0;
    border-left: 3px solid var(--primary);
}

.confidence-meter {
    display: flex;
    align-items: center;
    margin: 5px 0;
}

.confidence-bar {
    flex: 1;
    height: 6px;
    background: rgba(255, 255, 255, 0.1);
    border-radius: 3px;
    margin: 0 10px;
    overflow: hidden;
}

.confidence-fill {
    height: 100%;
    background: linear-gradient(90deg, #ff4444, #ffa500, var(--matrix));
    border-radius: 3px;
}
</style>
<script>
// ГЛАВНЫЙ КЛАСС SHAMANAI - ФИНАЛЬНАЯ ИНТЕГРАЦИЯ
class ShamanAIFinal {
    constructor() {
        this.systems = {
            text: new AdvancedTextGenerator(),
            image: new AdvancedImageAnalysis(),
            math: new AdvancedMathSolver(),
            api: new ExternalAPIIntegration(),
            memory: new MemorySystem(),
            graphics: new GraphicsRenderer()
        };
        
        this.conversationContext = [];
        this.userPreferences = {};
        this.systemStatus = 'initializing';
        this.isInitialized = false;
        
        this.init();
    }

    async init() {
        try {
            console.log("🚀 Инициализация ShamanAI...");
            
            // Параллельная инициализация всех систем
            await Promise.all([
                this.systems.text.init?.(),
                this.systems.image.initOCR?.(),
                this.systems.memory.load?.(),
                this.loadUserPreferences()
            ]);
            
            this.systemStatus = 'ready';
            this.isInitialized = true;
            
            console.log("✅ ShamanAI полностью инициализирован");
            this.logSystemStatus();
            
        } catch (error) {
            console.error("❌ Ошибка инициализации ShamanAI:", error);
            this.systemStatus = 'error';
        }
    }

    async processMessage(userInput, imageData = null, options = {}) {
        if (!this.isInitialized) {
            return "🔄 Система инициализируется, пожалуйста, подождите...";
        }

        // Анализ типа запроса
        const requestType = this.analyzeRequestType(userInput, imageData);
        const context = this.prepareContext(userInput);
        
        let response;

        try {
            switch (requestType) {
                case 'image_analysis':
                    response = await this.processImageRequest(userInput, imageData, context);
                    break;
                    
                case 'math_problem':
                    response = await this.processMathRequest(userInput, context);
                    break;
                    
                case 'graph_request':
                    response = await this.processGraphRequest(userInput, context);
                    break;
                    
                case 'memory_query':
                    response = await this.processMemoryRequest(userInput, context);
                    break;
                    
                case 'api_request':
                    response = await this.processAPIRequest(userInput, context);
                    break;
                    
                default:
                    response = await this.processConversationalRequest(userInput, context);
            }

            // Сохранение в память
            await this.systems.memory.saveInteraction?.(userInput, response, requestType);
            
            // Обновление контекста
            this.updateConversationContext(userInput, response);
            
            return this.formatFinalResponse(response, requestType);

        } catch (error) {
            console.error("Ошибка обработки запроса:", error);
            return this.handleError(error, userInput, requestType);
        }
    }

    analyzeRequestType(userInput, imageData) {
        if (imageData) return 'image_analysis';
        
        const input = userInput.toLowerCase();
        
        // Определение типа запроса по ключевым словам
        if (this.containsMathKeywords(input)) return 'math_problem';
        if (this.containsGraphKeywords(input)) return 'graph_request';
        if (this.containsMemoryKeywords(input)) return 'memory_query';
        if (this.containsAPIKeywords(input)) return 'api_request';
        if (this.containsImageKeywords(input)) return 'image_analysis';
        
        return 'conversational';
    }

    containsMathKeywords(input) {
        const mathWords = ['реши', 'посчитай', 'уравнение', 'формула', 'производная', 'интеграл', 'алгебра', 'геометрия'];
        return mathWords.some(word => input.includes(word));
    }

    containsGraphKeywords(input) {
        const graphWords = ['график', 'построй', 'диаграмма', 'chart', 'plot', 'функция'];
        return graphWords.some(word => input.includes(word));
    }

    containsMemoryKeywords(input) {
        const memoryWords = ['помнишь', 'вспомни', 'ранее', 'предыдущ', 'история'];
        return memoryWords.some(word => input.includes(word));
    }

    containsAPIKeywords(input) {
        const apiWords = ['погода', 'курс', 'новости', 'перевод', 'поиск'];
        return apiWords.some(word => input.includes(word));
    }

    containsImageKeywords(input) {
        const imageWords = ['изображен', 'фото', 'картинк', 'скриншот', 'рисунок'];
        return imageWords.some(word => input.includes(word));
    }

    prepareContext(userInput) {
        return {
            timestamp: new Date(),
            userInput: userInput,
            previousContext: this.conversationContext.slice(-4),
            userPreferences: this.userPreferences,
            systemStatus: this.systemStatus
        };
    }

    async processImageRequest(userInput, imageData, context) {
        const analysis = await this.systems.image.analyzeImage(imageData);
        
        let response = "🔍 **Результаты анализа изображения:**\n\n";
        response += `📊 Тип: ${analysis.imageType}\n`;
        response += `🎯 Уверенность: ${analysis.confidence}%\n\n`;
        
        if (analysis.text) {
            response += `📝 Текст: ${analysis.text.substring(0, 300)}...\n\n`;
        }
        
        if (analysis.formulas.length > 0) {
            response += `🧮 Обнаружены формулы:\n`;
            analysis.formulas.forEach(formula => {
                response += `• ${formula}\n`;
            });
            response += `\n`;
            
            // Автоматическое решение формул
            const solutions = await this.solveFormulas(analysis.formulas);
            if (solutions) {
                response += `🔢 Решения:\n${solutions}\n\n`;
            }
        }
        
        if (analysis.extractedData) {
            response += this.formatAnalysisData(analysis.extractedData);
        }
        
        // Интеграция с текстовой генерацией для контекстного ответа
        const contextualResponse = await this.systems.text.generateIntelligentResponse(
            `Проанализировал изображение: ${analysis.text?.substring(0, 200)}. ${userInput}`
        );
        
        response += `\n💭 **Анализ:** ${contextualResponse}`;
        
        return response;
    }

    async processMathRequest(userInput, context) {
        const solution = await this.systems.math.solveProblem(userInput);
        
        let response = "🧮 **Математическое решение:**\n\n";
        response += `📝 Задача: ${solution.problem}\n\n`;
        response += `📋 Пошаговое решение:\n`;
        
        solution.steps.forEach((step, index) => {
            response += `${step}\n`;
        });
        
        response += `\n✅ **Ответ:** ${solution.answer}\n`;
        
        if (solution.verification) {
            response += `🔍 Проверка: ${solution.verification.method} `;
            response += `(уверенность: ${Math.round(solution.verification.confidence * 100)}%)\n`;
        }
        
        // Дополнительное объяснение
        const explanation = await this.systems.text.generateIntelligentResponse(
            `Объясни математическое решение: ${solution.answer} для задачи: ${userInput}`
        );
        
        response += `\n💡 **Объяснение:** ${explanation}`;
        
        return response;
    }

    async processGraphRequest(userInput, context) {
        const functionMatch = userInput.match(/(?:y\s*=\s*|функция:\s*|график\s+)([^,\n]+)/i);
        
        if (functionMatch) {
            const func = functionMatch[1];
            const graphCanvas = this.systems.graphics.plotFunction(func);
            
            return {
                text: `✅ Построен график функции: ${func}`,
                graph: graphCanvas,
                function: func
            };
        }
        
        return "Укажите функцию для построения графика. Например: 'y = x^2' или 'sin(x)*cos(x)'";
    }

    async processMemoryRequest(userInput, context) {
        const memories = await this.systems.memory.search?.(userInput);
        
        if (memories && memories.length > 0) {
            let response = "🎭 **Из памяти ShamanAI:**\n\n";
            
            memories.slice(0, 3).forEach(memory => {
                response += `• ${memory.content} (${new Date(memory.timestamp).toLocaleDateString()})\n`;
            });
            
            return response;
        }
        
        return "В моей памяти нет相关信息 по вашему запросу. Давайте создадим новые воспоминания!";
    }

    async processAPIRequest(userInput, context) {
        // Интеграция с внешними API
        const apiResponse = await this.systems.api.generateWithAPI(userInput, context);
        return `🌐 **Информация из внешних источников:**\n\n${apiResponse}`;
    }

    async processConversationalRequest(userInput, context) {
        const useAdvancedAI = localStorage.getItem('shamanai_api_key') && 
                             localStorage.getItem('shamanai_model') !== 'local';
        
        let response;
        
        if (useAdvancedAI) {
            response = await this.systems.api.generateWithAPI(userInput, this.conversationContext);
        } else {
            response = await this.systems.text.generateIntelligentResponse(userInput, this.conversationContext);
        }
        
        return response;
    }

    async solveFormulas(formulas) {
        let solutions = '';
        
        for (const formula of formulas.slice(0, 3)) {
            try {
                const solution = await this.systems.math.solveProblem(formula);
                solutions += `• ${formula} → ${solution.answer}\n`;
            } catch (error) {
                solutions += `• ${formula} → не удалось решить\n`;
            }
        }
        
        return solutions;
    }

    formatAnalysisData(data) {
        let formatted = '';
        
        switch (data.type) {
            case 'handwritten_mathematics':
                formatted += `✍️ Рукописная математика:\n`;
                if (data.equations?.length > 0) {
                    formatted += `Уравнения: ${data.equations.join(', ')}\n`;
                }
                break;
                
            case 'physics_diagram':
                formatted += `⚡ Физическая схема:\n`;
                if (data.components?.length > 0) {
                    formatted += `Элементы: ${data.components.join(', ')}\n`;
                }
                break;
                
            case 'screenshot':
                formatted += `📱 Образовательный контент:\n`;
                if (data.homeworkInfo?.subject) {
                    formatted += `Предмет: ${data.homeworkInfo.subject}\n`;
                }
                break;
        }
        
        return formatted;
    }

    formatFinalResponse(response, requestType) {
        if (typeof response === 'object' && response.graph) {
            // Ответ содержит график
            return response;
        }
        
        const prefixes = {
            'image_analysis': '🔍',
            'math_problem': '🧮', 
            'graph_request': '📊',
            'memory_query': '🎭',
            'api_request': '🌐',
            'conversational': '💬'
        };
        
        const prefix = prefixes[requestType] || '💬';
        return `${prefix} ${response}`;
    }

    handleError(error, userInput, requestType) {
        console.error(`Ошибка в ${requestType}:`, error);
        
        const errorMessages = {
            'image_analysis': "❌ Не удалось проанализировать изображение. Проверьте формат файла.",
            'math_problem': "❌ Ошибка решения задачи. Проверьте корректность условия.",
            'graph_request': "❌ Не удалось построить график. Проверьте функцию.",
            'default': "❌ Произошла ошибка. Попробуйте еще раз или переформулируйте запрос."
        };
        
        const errorMessage = errorMessages[requestType] || errorMessages.default;
        
        // Логирование ошибки для улучшения системы
        this.systems.memory.saveError?.(error, userInput, requestType);
        
        return errorMessage;
    }

    updateConversationContext(userInput, aiResponse) {
        this.conversationContext.push({
            role: 'user',
            content: userInput,
            timestamp: new Date()
        }, {
            role: 'assistant', 
            content: aiResponse,
            timestamp: new Date()
        });
        
        // Ограничение размера контекста
        if (this.conversationContext.length > 20) {
            this.conversationContext = this.conversationContext.slice(-20);
        }
    }

    async loadUserPreferences() {
        try {
            const preferences = localStorage.getItem('shamanai_preferences');
            if (preferences) {
                this.userPreferences = JSON.parse(preferences);
            }
        } catch (error) {
            console.warn("Не удалось загрузить настройки пользователя");
        }
    }

    logSystemStatus() {
        const status = {
            'Текстовая генерация': '✅',
            'Анализ изображений': this.systems.image.isOCRReady ? '✅' : '⚠️',
            'Математический решатель': '✅',
            'Система памяти': '✅',
            'Графический рендерер': '✅',
            'API интеграция': '✅'
        };
        
        console.log("📊 Статус систем ShamanAI:");
        Object.entries(status).forEach(([system, stat]) => {
            console.log(`${stat} ${system}`);
        });
    }

    // Дополнительные методы управления
    clearConversation() {
        this.conversationContext = [];
        return "🗑️ История разговора очищена.";
    }

    getSystemInfo() {
        return {
            version: "2.0.0",
            status: this.systemStatus,
            contextLength: this.conversationContext.length,
            features: {
                textGeneration: true,
                imageAnalysis: true,
                mathSolving: true,
                memory: true,
                graphics: true,
                apiIntegration: true
            }
        };
    }

    exportConversation() {
        return {
            timestamp: new Date(),
            context: this.conversationContext,
            userPreferences: this.userPreferences
        };
    }
}

// СИСТЕМА ПАМЯТИ ДЛЯ SHAMANAI
class MemorySystem {
    constructor() {
        this.memoryKey = 'shamanai_memory';
        this.maxMemories = 100;
        this.memories = [];
        this.load();
    }

    async saveInteraction(userInput, aiResponse, type) {
        const memory = {
            id: Date.now(),
            timestamp: new Date(),
            type: type,
            userInput: userInput,
            aiResponse: aiResponse,
            tags: this.extractTags(userInput)
        };
        
        this.memories.unshift(memory);
        
        // Ограничение количества воспоминаний
        if (this.memories.length > this.maxMemories) {
            this.memories = this.memories.slice(0, this.maxMemories);
        }
        
        await this.save();
        return memory;
    }

    async search(query, limit = 5) {
        const queryLower = query.toLowerCase();
        
        return this.memories.filter(memory => {
            return memory.userInput.toLowerCase().includes(queryLower) ||
                   memory.aiResponse.toLowerCase().includes(queryLower) ||
                   memory.tags.some(tag => tag.includes(queryLower));
        }).slice(0, limit);
    }

    extractTags(text) {
        const tags = [];
        const words = text.toLowerCase().split(/\s+/);
        
        const keyTopics = ['математика', 'физика', 'программирование', 'наука', 'технологии', 
                          'образование', 'график', 'формула', 'уравнение'];
        
        keyTopics.forEach(topic => {
            if (text.toLowerCase().includes(topic)) {
                tags.push(topic);
            }
        });
        
        return tags.slice(0, 5);
    }

    async saveError(error, userInput, context) {
        const errorMemory = {
            type: 'error',
            timestamp: new Date(),
            error: error.message,
            userInput: userInput,
            context: context,
            stack: error.stack
        };
        
        // Сохранение ошибок в отдельном хранилище
        const errors = JSON.parse(localStorage.getItem('shamanai_errors') || '[]');
        errors.unshift(errorMemory);
        
        if (errors.length > 50) {
            errors.pop();
        }
        
        localStorage.setItem('shamanai_errors', JSON.stringify(errors));
    }

    async load() {
        try {
            const saved = localStorage.getItem(this.memoryKey);
            if (saved) {
                this.memories = JSON.parse(saved);
            }
        } catch (error) {
            console.warn("Не удалось загрузить память:", error);
            this.memories = [];
        }
    }

    async save() {
        try {
            localStorage.setItem(this.memoryKey, JSON.stringify(this.memories));
        } catch (error) {
            console.warn("Не удалось сохранить память:", error);
        }
    }

    clear() {
        this.memories = [];
        this.save();
    }

    getStats() {
        return {
            totalMemories: this.memories.length,
            lastUpdated: this.memories[0]?.timestamp || null,
            memoryTypes: this.getMemoryTypeCounts()
        };
    }

    getMemoryTypeCounts() {
        const counts = {};
        this.memories.forEach(memory => {
            counts[memory.type] = (counts[memory.type] || 0) + 1;
        });
        return counts;
    }
}

// СИСТЕМА ГРАФИКОВ И ВИЗУАЛИЗАЦИИ
class GraphicsRenderer {
    constructor() {
        this.chartInstances = new Map();
    }

    plotFunction(func, options = {}) {
        const canvas = document.createElement('canvas');
        canvas.width = options.width || 600;
        canvas.height = options.height || 400;
        canvas.className = 'shamanai-graph';
        
        const ctx = canvas.getContext('2d');
        
        // Настройки графика
        const config = {
            xMin: options.xMin || -10,
            xMax: options.xMax || 10,
            color: options.color || '#8A2BE2',
            lineWidth: options.lineWidth || 3
        };
        
        this.drawFunctionOnCanvas(ctx, func, config, canvas.width, canvas.height);
        
        return canvas;
    }

    drawFunctionOnCanvas(ctx, func, config, width, height) {
        const { xMin, xMax, color, lineWidth } = config;
        const padding = 40;
        const graphWidth = width - 2 * padding;
        const graphHeight = height - 2 * padding;
        
        // Очистка и фон
        ctx.fillStyle = 'rgba(26, 26, 46, 0.9)';
        ctx.fillRect(0, 0, width, height);
        
        // Оси координат
        ctx.strokeStyle = '#00CED1';
        ctx.lineWidth = 2;
        
        // Ось X
        ctx.beginPath();
        ctx.moveTo(0, height - padding);
        ctx.lineTo(width, height - padding);
        ctx.stroke();
        
        // Ось Y
        ctx.beginPath();
        ctx.moveTo(padding, 0);
        ctx.lineTo(padding, height);
        ctx.stroke();
        
        // Сетка
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
        ctx.lineWidth = 1;
        
        // Вертикальные линии сетки
        for (let x = xMin; x <= xMax; x += 2) {
            const pixelX = padding + (x - xMin) * (graphWidth / (xMax - xMin));
            ctx.beginPath();
            ctx.moveTo(pixelX, 0);
            ctx.lineTo(pixelX, height);
            ctx.stroke();
        }
        
        // Горизонтальные линии сетки
        const yRange = 20;
        for (let y = -10; y <= 10; y += 2) {
            const pixelY = height - padding - (y + 10) * (graphHeight / yRange);
            ctx.beginPath();
            ctx.moveTo(0, pixelY);
            ctx.lineTo(width, pixelY);
            ctx.stroke();
        }
        
        // Построение графика функции
        ctx.strokeStyle = color;
        ctx.lineWidth = lineWidth;
        ctx.beginPath();
        
        let firstPoint = true;
        
        for (let x = xMin; x <= xMax; x += 0.1) {
            try {
                // Заменяем математические функции и константы
                const processedFunc = func
                    .replace(/sin/g, 'Math.sin')
                    .replace(/cos/g, 'Math.cos')
                    .replace(/tan/g, 'Math.tan')
                    .replace(/sqrt/g, 'Math.sqrt')
                    .replace(/log/g, 'Math.log')
                    .replace(/pi/g, 'Math.PI')
                    .replace(/e/g, 'Math.E')
                    .replace(/\^/g, '**');
                
                const y = eval(processedFunc.replace(/x/g, `(${x})`));
                
                if (isNaN(y) || !isFinite(y)) {
                    firstPoint = true;
                    continue;
                }
                
                const pixelX = padding + (x - xMin) * (graphWidth / (xMax - xMin));
                const pixelY = height - padding - (y + 10) * (graphHeight / 20);
                
                if (firstPoint) {
                    ctx.moveTo(pixelX, pixelY);
                    firstPoint = false;
                } else {
                    ctx.lineTo(pixelX, pixelY);
                }
            } catch (error) {
                firstPoint = true;
            }
        }
        
        ctx.stroke();
        
        // Подписи осей
        ctx.fillStyle = '#F0F8FF';
        ctx.font = '12px Courier New';
        ctx.fillText('x', width - 20, height - padding + 20);
        ctx.fillText('y', padding - 20, 20);
        
        return canvas;
    }

    createPhysicsDiagram(type, parameters) {
        const canvas = document.createElement('canvas');
        canvas.width = 500;
        canvas.height = 300;
        canvas.className = 'shamanai-diagram';
        
        const ctx = canvas.getContext('2d');
        
        switch (type) {
            case 'electrical_circuit':
                this.drawElectricalCircuit(ctx, parameters);
                break;
            case 'mechanical_system':
                this.drawMechanicalSystem(ctx, parameters);
                break;
            case 'optical_diagram':
                this.drawOpticalDiagram(ctx, parameters);
                break;
        }
        
        return canvas;
    }

    drawElectricalCircuit(ctx, params) {
        ctx.fillStyle = 'rgba(26, 26, 46, 0.9)';
        ctx.fillRect(0, 0, 500, 300);
        
        ctx.strokeStyle = '#00CED1';
        ctx.lineWidth = 3;
        ctx.fillStyle = '#F0F8FF';
        ctx.font = '14px Courier New';
        
        // Батарея
        ctx.fillRect(50, 100, 40, 100);
        ctx.fillText('Батарея', 35, 90);
        
        // Резисторы
        ctx.fillRect(150, 100, 60, 20);
        ctx.fillText('R1', 170, 90);
        
        ctx.fillRect(150, 180, 60, 20);
        ctx.fillText('R2', 170, 250);
        
        // Конденсатор
        ctx.fillRect(280, 80, 10, 60);
        ctx.fillRect(300, 80, 10, 60);
        ctx.fillText('C1', 285, 70);
        
        // Соединения
        ctx.beginPath();
        ctx.moveTo(90, 100); ctx.lineTo(150, 100);
        ctx.moveTo(210, 110); ctx.lineTo(280, 110);
        ctx.moveTo(310, 110); ctx.lineTo(400, 110);
        ctx.moveTo(50, 200); ctx.lineTo(400, 200);
        ctx.stroke();
    }

    drawMechanicalSystem(ctx, params) {
        // Реализация механической системы
        ctx.fillStyle = 'rgba(26, 26, 46, 0.9)';
        ctx.fillRect(0, 0, 500, 300);
        
        ctx.strokeStyle = '#FF1493';
        ctx.lineWidth = 3;
        ctx.fillStyle = '#F0F8FF';
        ctx.font = '14px Courier New';
        
        // Пружина
        this.drawSpring(ctx, 100, 150, 200, 150);
        ctx.fillText('Пружина', 150, 140);
        
        // Масса
        ctx.fillRect(200, 130, 60, 40);
        ctx.fillText('Масса m', 210, 125);
        
        // Опора
        ctx.fillRect(80, 140, 20, 60);
        ctx.fillText('Опора', 60, 220);
    }

    drawSpring(ctx, x1, y1, x2, y2) {
        const segments = 8;
        const dx = (x2 - x1) / segments;
        const amplitude = 10;
        
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        
        for (let i = 1; i < segments; i++) {
            const x = x1 + i * dx;
            const y = y1 + (i % 2 === 0 ? -amplitude : amplitude);
            ctx.lineTo(x, y);
        }
        
        ctx.lineTo(x2, y2);
        ctx.stroke();
    }

    drawOpticalDiagram(ctx, params) {
        ctx.fillStyle = 'rgba(26, 26, 46, 0.9)';
        ctx.fillRect(0, 0, 500, 300);
        
        ctx.strokeStyle = '#8A2BE2';
        ctx.lineWidth = 2;
        ctx.fillStyle = '#F0F8FF';
        ctx.font = '14px Courier New';
        
        // Линза
        ctx.beginPath();
        ctx.ellipse(250, 150, 20, 80, 0, 0, 2 * Math.PI);
        ctx.stroke();
        ctx.fillText('Линза', 240, 80);
        
        // Лучи
        ctx.beginPath();
        ctx.moveTo(50, 100); ctx.lineTo(230, 150);
        ctx.moveTo(50, 200); ctx.lineTo(230, 150);
        ctx.moveTo(270, 150); ctx.lineTo(450, 120);
        ctx.moveTo(270, 150); ctx.lineTo(450, 180);
        ctx.stroke();
        
        ctx.fillText('Предмет', 30, 220);
        ctx.fillText('Изображение', 400, 220);
    }
}

// ФИНАЛЬНАЯ ИНИЦИАЛИЗАЦИЯ И ИНТЕГРАЦИЯ
let finalShamanAI;

async function initializeFinalShamanAI() {
    try {
        finalShamanAI = new ShamanAIFinal();
        
        // Ждем полной инициализации
        await new Promise(resolve => {
            const checkInit = setInterval(() => {
                if (finalShamanAI.isInitialized) {
                    clearInterval(checkInit);
                    resolve();
                }
            }, 100);
        });
        
        console.log("🎉 ShamanAI 2.0 готов к работе!");
        return true;
        
    } catch (error) {
        console.error("Ошибка инициализации ShamanAI:", error);
        return false;
    }
}

// ОБНОВЛЕННЫЙ ИНТЕРФЕЙС И УПРАВЛЕНИЕ
function setupFinalInterface() {
    // Добавление расширенной панели управления
    const toolsPanel = document.querySelector('.tools-panel');
    
    const finalControls = document.createElement('div');
    finalControls.className = 'tool-section';
    finalControls.innerHTML = `
        <h3 class="tool-title">🎛️ УПРАВЛЕНИЕ СИСТЕМОЙ</h3>
        <button class="button" onclick="showSystemInfo()" style="width: 100%; margin-bottom: 10px;">ИНФО СИСТЕМЫ</button>
        <button class="button" onclick="exportConversation()" style="width: 100%; margin-bottom: 10px;">ЭКСПОРТ ЧАТА</button>
        <button class="button" onclick="clearAllData()" style="width: 100%; margin-bottom: 10px; background: linear-gradient(45deg, #FF4444, #FF1493);">ОЧИСТИТЬ ВСЁ</button>
        <button class="button" onclick="toggleAdvancedMode()" style="width: 100%; background: linear-gradient(45deg, #00CED1, #20B2AA);">РЕЖИМ ЭКСПЕРТА</button>
    `;
    
    toolsPanel.appendChild(finalControls);
    
    // Добавление индикатора статуса системы
    const statusIndicator = document.createElement('div');
    statusIndicator.id = 'systemStatusIndicator';
    statusIndicator.className = 'system-status-panel';
    statusIndicator.innerHTML = `
        <div class="status-item">
            <span>Статус системы:</span>
            <span id="currentSystemStatus" class="matrix-text">🔄 ИНИЦИАЛИЗАЦИЯ</span>
        </div>
    `;
    
    toolsPanel.insertBefore(statusIndicator, toolsPanel.firstChild);
}

// ФУНКЦИИ УПРАВЛЕНИЯ
async function showSystemInfo() {
    if (!finalShamanAI) return;
    
    const info = finalShamanAI.getSystemInfo();
    const memoryStats = finalShamanAI.systems.memory.getStats?.() || {};
    
    let message = `🤖 **ShamanAI System Information**\n\n`;
    message += `• Версия: ${info.version}\n`;
    message += `• Статус: ${info.status}\n`;
    message += `• Размер контекста: ${info.contextLength} сообщений\n`;
    message += `• Воспоминаний: ${memoryStats.totalMemories || 0}\n\n`;
    message += `**Активные функции:**\n`;
    
    Object.entries(info.features).forEach(([feature, enabled]) => {
        message += `• ${feature}: ${enabled ? '✅' : '❌'}\n`;
    });
    
    addMessageToChat(message, 'ai');
}

async function exportConversation() {
    if (!finalShamanAI) return;
    
    const data = finalShamanAI.exportConversation();
    const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    
    const a = document.createElement('a');
    a.href = url;
    a.download = `shamanai-chat-${new Date().toISOString().split('T')[0]}.json`;
    a.click();
    
    URL.revokeObjectURL(url);
    addMessageToChat("💾 Чат экспортирован в JSON файл", 'ai');
}

async function clearAllData() {
    if (confirm("Вы уверены, что хотите очистить все данные? Это действие нельзя отменить.")) {
        localStorage.clear();
        if (finalShamanAI) {
            finalShamanAI.clearConversation();
            finalShamanAI.systems.memory.clear?.();
        }
        
        const chatMessages = document.getElementById('chatMessages');
        chatMessages.innerHTML = '<div class="message ai-message"><span class="matrix-text">>> СИСТЕМА СБРОШЕНА</span><br>Все данные очищены. Система готова к новой работе.</div>';
        
        document.getElementById('mathOutput').innerHTML = '<span class="matrix-text">>> СИСТЕМА ОЧИЩЕНА</span><br>Здесь появятся новые решения...';
    }
}

function toggleAdvancedMode() {
    const advancedMode = localStorage.getItem('shamanai_advanced') === 'true';
    localStorage.setItem('shamanai_advanced', (!advancedMode).toString());
    
    addMessageToChat(
        advancedMode ? 
        "🔒 Режим эксперта отключен" : 
        "🔓 <span class='matrix-text'>РЕЖИМ ЭКСПЕРТА АКТИВИРОВАН</span><br>Доступны расширенные функции и настройки.",
        'ai'
    );
}

// ОБНОВЛЕННАЯ ФУНКЦИЯ ОБРАБОТКИ СООБЩЕНИЙ
async function processFinalInput() {
    const input = document.getElementById('chatInput');
    const message = input.value.trim();
    
    if (!message && !currentImage) return;
    
    if (message) {
        addMessageToChat(message, 'user');
        input.value = '';
        
        showTypingIndicator();
        
        try {
            const response = await finalShamanAI.processMessage(message, currentImage);
            hideTypingIndicator();
            
            if (typeof response === 'object' && response.graph) {
                // Ответ содержит график
                addMessageToChat(response.text, 'ai');
                addGraphToChat(response.graph);
            } else {
                addMessageToChat(response, 'ai');
            }
            
            // Обновление вывода
            document.getElementById('mathOutput').innerHTML = 
                typeof response === 'string' ? response.replace(/\n/g, '<br>') : response.text;
            
        } catch (error) {
            hideTypingIndicator();
            addMessageToChat("❌ Критическая ошибка системы. Попробуйте перезагрузить страницу.", "ai");
            console.error("Final AI Error:", error);
        }
        
        currentImage = null;
        document.getElementById('previewCanvas').style.display = 'none';
    }
}

function addGraphToChat(canvas) {
    const chatMessages = document.getElementById('chatMessages');
    const messageDiv = document.createElement('div');
    messageDiv.className = 'message ai-message';
    messageDiv.appendChild(canvas);
    chatMessages.appendChild(messageDiv);
    chatMessages.scrollTop = chatMessages.scrollHeight;
}

// ОБНОВЛЕНИЕ СТАТУСА СИСТЕМЫ
function updateSystemStatus() {
    if (!finalShamanAI) return;
    
    const statusElement = document.getElementById('currentSystemStatus');
    if (statusElement) {
        const status = finalShamanAI.systemStatus;
        const statusText = {
            'initializing': '🔄 ИНИЦИАЛИЗАЦИЯ',
            'ready': '✅ ГОТОВ',
            'error': '❌ ОШИБКА'
        }[status] || '❓ НЕИЗВЕСТНО';
        
        statusElement.textContent = statusText;
    }
}

// ФИНАЛЬНАЯ ИНИЦИАЛИЗАЦИЯ ПРИ ЗАГРУЗКЕ
window.addEventListener('load', async function() {
    // Показываем сообщение о загрузке
    addMessageToChat("🚀 <span class='matrix-text'>ЗАПУСК SHAMANAI 2.0</span><br>Инициализация продвинутой ИИ системы...", "ai");
    
    // Инициализация системы
    const success = await initializeFinalShamanAI();
    
    if (success) {
        addMessageToChat("✅ <span class='matrix-text'>СИСТЕМА АКТИВИРОВАНА</span><br>ShamanAI 2.0 готов к работе! Задавайте вопросы, загружайте изображения, решайте задачи - я помогу со всем!", "ai");
        setupFinalInterface();
        updateSystemStatus();
        
        // Устанавливаем финальную функцию обработки
        window.sendMessage = processFinalInput;
        
        // Обновляем статус каждые 5 секунд
        setInterval(updateSystemStatus, 5000);
        
    } else {
        addMessageToChat("❌ <span class='matrix-text'>ОШИБКА ИНИЦИАЛИЗАЦИИ</span><br>Не удалось запустить систему. Пожалуйста, перезагрузите страницу.", "ai");
    }
});

// ГЛОБАЛЬНЫЕ ПЕРЕМЕННЫЕ
let currentImage = null;

// СТАНДАРТНЫЕ ФУНКЦИИ ИНТЕРФЕЙСА
function addMessageToChat(message, sender) {
    const chatMessages = document.getElementById('chatMessages');
    const messageDiv = document.createElement('div');
    messageDiv.className = `message ${sender}-message`;
    messageDiv.innerHTML = message;
    chatMessages.appendChild(messageDiv);
    chatMessages.scrollTop = chatMessages.scrollHeight;
}

function showTypingIndicator() {
    document.getElementById('typingIndicator').style.display = 'block';
}

function hideTypingIndicator() {
    document.getElementById('typingIndicator').style.display = 'none';
}

function handleImageUpload(event) {
    const file = event.target.files[0];
    if (!file) return;
    
    const reader = new FileReader();
    reader.onload = function(e) {
        const img = new Image();
        img.onload = function() {
            const canvas = document.getElementById('previewCanvas');
            const ctx = canvas.getContext('2d');
            
            const maxWidth = 400;
            const scale = Math.min(maxWidth / img.width, 1);
            canvas.width = img.width * scale;
            canvas.height = img.height * scale;
            
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
            canvas.style.display = 'block';
            
            currentImage = canvas;
        };
        img.src = e.target.result;
    };
    reader.readAsDataURL(file);
}

function analyzeImage() {
    if (!currentImage) {
        addMessageToChat("❌ Сначала загрузите изображение", 'ai');
        return;
    }
    
    addMessageToChat("🖼️ Анализирую изображение...", 'user');
    processFinalInput();
}
</script>

<style>
/* ФИНАЛЬНЫЕ СТИЛИ SHAMANAI 2.0 */
.shamanai-graph {
    border: 2px solid var(--secondary);
    border-radius: 10px;
    margin: 10px 0;
    background: rgba(26, 26, 46, 0.9);
    box-shadow: var(--neon-glow);
}

.shamanai-diagram {
    border: 2px solid var(--primary);
    border-radius: 10px;
    margin: 10px 0;
    background: rgba(26, 26, 46, 0.9);
}

.system-status-panel {
    background: rgba(0, 0, 0, 0.7);
    border: 2px solid var(--matrix);
    border-radius: 10px;
    padding: 15px;
    margin: 10px 0;
    backdrop-filter: blur(10px);
}

.status-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin: 8px 0;
    padding: 8px;
    background: rgba(255, 255, 255, 0.05);
    border-radius: 5px;
    border-left: 3px solid var(--matrix);
}

.export-button {
    background: linear-gradient(45deg, var(--secondary), var(--matrix));
    border: none;
    padding: 10px 20px;
    border-radius: 8px;
    color: white;
    cursor: pointer;
    transition: all 0.3s ease;
    margin: 5px;
}

.export-button:hover {
    transform: translateY(-2px);
    box-shadow: 0 0 15px var(--matrix);
}

.memory-badge {
    display: inline-block;
    background: rgba(138, 43, 226, 0.3);
    border: 1px solid var(--primary);
    border-radius: 12px;
    padding: 2px 8px;
    font-size: 0.7em;
    margin-left: 8px;
}

.context-indicator {
    position: fixed;
    bottom: 20px;
    left: 20px;
    background: rgba(0, 0, 0, 0.8);
    padding: 10px 15px;
    border-radius: 20px;
    border: 1px solid var(--secondary);
    font-size: 0.8em;
    backdrop-filter: blur(5px);
}

.advanced-mode {
    border: 2px solid var(--matrix) !important;
    box-shadow: 0 0 20px var(--matrix) !important;
}

.performance-monitor {
    position: fixed;
    top: 20px;
    right: 20px;
    background: rgba(0, 0, 0, 0.8);
    padding: 10px;
    border-radius: 10px;
    border: 1px solid var(--accent);
    font-size: 0.7em;
    backdrop-filter: blur(5px);
}

.matrix-border {
    position: relative;
    border: 1px solid var(--matrix);
    border-radius: 10px;
    padding: 2px;
    background: linear-gradient(45deg, transparent, rgba(0, 255, 65, 0.1), transparent);
}

@keyframes matrixFlow {
    0% { background-position: 0% 50%; }
    50% { background-position: 100% 50%; }
    100% { background-position: 0% 50%; }
}

.animated-background {
    background: linear-gradient(-45deg, var(--dark), #16213E, #0F3460, var(--dark));
    background-size: 400% 400%;
    animation: matrixFlow 10s ease infinite;
}

/* АДАПТИВНОСТЬ */
@media (max-width: 768px) {
    .main-grid {
        grid-template-columns: 1fr;
    }
    
    .shaman-title {
        font-size: 2.5rem;
    }
    
    .chat-messages {
        height: 400px;
    }
    
    .context-indicator,
    .performance-monitor {
        position: static;
        margin: 10px;
    }
    
    .shamanai-graph,
    .shamanai-diagram {
        width: 100%;
        height: auto;
    }
}

/* АНИМАЦИИ */
@keyframes systemReady {
    0% { transform: scale(0.8); opacity: 0; }
    50% { transform: scale(1.05); }
    100% { transform: scale(1); opacity: 1; }
}

.system-ready {
    animation: systemReady 0.5s ease-out;
}

@keyframes dataFlow {
    0% { transform: translateX(-100%); }
    100% { transform: translateX(100%); }
}

.data-flow {
    position: relative;
    overflow: hidden;
}

.data-flow::after {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 2px;
    background: linear-gradient(90deg, transparent, var(--matrix), transparent);
    animation: dataFlow 2s infinite;
}

/* ТЕМЫ */
.dark-theme {
    --primary: #8A2BE2;
    --secondary: #00CED1;
    --accent: #FF1493;
    --dark: #1A1A2E;
    --light: #F0F8FF;
}

.matrix-theme {
    --primary: #00FF41;
    --secondary: #008F11;
    --accent: #00FF88;
    --dark: #0A0A0A;
    --light: #00FF41;
}

.neon-theme {
    --primary: #FF00FF;
    --secondary: #00FFFF;
    --accent: #FFFF00;
    --dark: #000000;
    --light: #FFFFFF;
}

.theme-selector {
    position: fixed;
    bottom: 20px;
    right: 20px;
    background: rgba(0, 0, 0, 0.8);
    padding: 10px;
    border-radius: 10px;
    border: 1px solid var(--secondary);
    backdrop-filter: blur(5px);
}

.theme-button {
    width: 20px;
    height: 20px;
    border-radius: 50%;
    margin: 5px;
    cursor: pointer;
    border: 2px solid transparent;
}

.theme-button.active {
    border-color: white;
}

.theme-dark { background: #8A2BE2; }
.theme-matrix { background: #00FF41; }
.theme-neon { background: #FF00FF; }
</style>

<!-- ДОПОЛНИТЕЛЬНЫЕ ЭЛЕМЕНТЫ ИНТЕРФЕЙСА -->
<div class="context-indicator" id="contextIndicator">
    <span class="matrix-text">Контекст: </span>
    <span id="contextCount">0</span> сообщений
</div>

<div class="performance-monitor">
    <div>CPU: <span id="cpuUsage">--%</span></div>
    <div>Память: <span id="memoryUsage">--MB</span></div>
    <div>Время: <span id="responseTime">--ms</span></div>
</div>

<div class="theme-selector">
    <div class="theme-button theme-dark active" onclick="changeTheme('dark')"></div>
    <div class="theme-button theme-matrix" onclick="changeTheme('matrix')"></div>
    <div class="theme-button theme-neon" onclick="changeTheme('neon')"></div>
</div>

<script>
// ДОПОЛНИТЕЛЬНЫЕ ФУНКЦИИ УПРАВЛЕНИЯ
function updateContextIndicator() {
    if (finalShamanAI) {
        const count = finalShamanAI.conversationContext.length;
        document.getElementById('contextCount').textContent = count;
    }
}

function changeTheme(theme) {
    document.body.className = theme + '-theme';
    
    // Обновляем активные кнопки темы
    document.querySelectorAll('.theme-button').forEach(btn => {
        btn.classList.remove('active');
    });
    event.target.classList.add('active');
}

// Мониторинг производительности
function startPerformanceMonitoring() {
    setInterval(() => {
        if (performance.memory) {
            const memory = performance.memory.usedJSHeapSize / 1024 / 1024;
            document.getElementById('memoryUsage').textContent = Math.round(memory);
        }
    }, 2000);
}

// Обновление индикатора контекста
setInterval(updateContextIndicator, 1000);

// Запуск мониторинга производительности
window.addEventListener('load', startPerformanceMonitoring);
</script>
